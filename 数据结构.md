# 数据结构

_与算法紧密相连_

---

## 第一章 初识数据结构与算法

### 1.1 什么是数据结构

---

#### 1.1.1 关于数据组织 书架放书问题

- 数据结构 图书如何放置？--数据的组织方式
- 算法 新书的插入、书籍查找

#### 1.1.2 关于空间使用 循环，递归问题

_空间的利用效率_

循环方式

```c++
void PrintN(unsigned int N)
{
    for (unsigned int i = 0; i < N; i++)
    {
        printf("%d ", i + 1);
    }
    printf("\n");
}
```

递归方式

```c++
void PrintN(unsigned int N)
{
    if (N)
    {
        PrintN(N - 1);
        printf("%lld ", N);
    }
}
```

在 N = 10 0000 时，递归出错，递归对于空间占用很大，空间溢出

#### 1.1.3 关于算法效率 多项式问题

**时间的利用效率**

无脑方式

```c++
double f1(int n, double arr[], double x)
{
    double res = arr[0];
    for (int i = 0; i < n - 1; i++)
    {
        res += arr[i + 1] * pow(x, i + 1);
    }
    return res;
}
```

秦九韶算法

```c++
double f2(int n, double arr[], double x)
{
    double res = arr[n - 1];
    for (int i = n - 2; i > -1; i--)
    {
        res *= x;
        res += arr[i];
    }
    return res;
}
```

效率对比

分别循环 1e7 次

> f1 4.256 seconds
> f2 0.708 seconds

_解决问题效率和算法巧妙程度有关_

#### 1.1.4 什么是数据结构?

- **数据对象在计算机中的组织方式**
  逻辑结构 _线性，树，图_
  物理存储结构 _数组，链表_
- 数据对象必定与一系列加在其上的**操作**相关联，实现这些操作所用的方法即为**算法**

#### 1.1.5 抽象数据类型

数据类型

- **数据对象**集
- 数据集合相关联的**操作**集

抽象 描述数据对象的方法不依赖于具体实现

- 与存放数据的机器无关
- 与数据存储的物理结构无关
- 与实现操作的算法和编程语言无关

\*只描述数据对象集和相关操作集**是什么**，并不涉及**如何做到的问题\***

_联想_ 只关心这个类的成员属性(**数据集**)是什么 有哪些方法(**操作集**)，而不涉及这个类成员属性的类型，及其成员函数如何实现

### 1.2 什么是算法

---

#### 1.2.1 算法的定义

- 一个**有限**指令集
- 接受或不接受一些输入
- 产生输出
- 一定在**有限步骤**之后终止
- 每一条指令必须有**充分明确的目标**，不可以有歧义，在**计算机能处理**的范围内，描述**不依赖于任何一种计算机语言以及具体的实现手段**

例 选择排序

```c++
void SelecttionSort(int List[], int N)
{
    /*将N个整数List[0]...List[N-1]进行非递减排序*/
    for(i = 0; i < N; i++)
    {
        MinPosition = ScanForMin(List, i, N-1);
        /*从List[i]到List[N-1]中找到最小元，并将其位置赋给MinPosition*/
        Swap(List[i], List[Minposition]);
        /*将未排序部分的最小元换到有序部分的最后位置*/
    }
}
```

List 不一定是数组，Swap 也不一定是函数

#### 1.2.2 什么是好的算法

**算法的空间复杂度** 衡量算法优劣的标准之一

- S(n)
- 根据算法写成的程序在执行时**占用的储存单元的长度**
- 过大会发生非正常中断

**算法的时间复杂度** 衡量算法优劣的标准之一

- T(n)
- 根据算法写成的程序在执行时**耗费时间的长度**
- 会时间过长

_n 数据的规模_

$T_{worst}$最坏复杂度和$T_{avg}$平均复杂度是我们常关心的,尤其是$T_{worst}$

#### 1.2.3 复杂度的渐进表示法

_粗略计算算法复杂度的增长趋势_

- $T(n)=o(f(n))$ 上界
- $T(n)=\Omega(f(n))$ 下界

复杂度

> $\log n<n<n\log n<n^2<2^n$

- 片段代码的复杂度取**各片段的最大值**(**注意片段不是和输入规模$n$有关的一次循环片段，是累加起来与$n$无关的普通片段**)
- 嵌套的复杂度等于**非嵌套二者的乘积**
- `for`循环的时间复杂度等于**循环次数乘以循环体代码**的复杂度
- `if else`结构的复杂度取决于**if 的条件判断复杂度和两个分支部分的复杂度**，总体复杂度**取三者中最大**

### 1.3 算法实例

---

#### 1.3.1 最大子列和问题 $O(n^3)$优化为$O(n^2)$

要求找到长度为 N 的列表中所有子列和的最大值

最容易想到的算法 找到所有子列分别求和

```c++
int MaxSubseqSum1(int A[], int N)
{
    int ThisSum, MaxSum = 0;
    int i, j, k;
    for (i = 0; i < N; i++) // 子列左端位置
    {
        for (j = i; i < N; j++) // 子列右端位置
        {
            ThisSum = 0;
            for (k = i; k <= j; k++) // 子列和
            {
                ThisSum += A[k];
            }
            if (ThisSum > MaxSum)
            {
                MaxSum = ThisSum;
            }
        }
    }
}
```

复杂度$O(n^3)$

分析发现在子列左端确定后，每一次改变子列右端都要重新从确定的左端计数，这是没有必要的

优化算法

```c++
int MaxSubseqSum2(int A[], int N)
{
    int ThisSum, MaxSum = 0;
    int i, j, k;
    for (i = 0; i < N; i++) // 子列左端位置
    {
        ThisSum = 0;
        for (j = i; i < N; j++) // 子列右端位置
        {
            ThisSum += A[j];
            // 确定子列起始位置后，不同终止位置的子列只需要在前一终止位置子列基础上累加一项
            if (ThisSum > MaxSum)
            {
                MaxSum = ThisSum;
            }
        }
    }
}
```

复杂度$O(n^2)$

#### 1.3.2 最大子列和问题 $O(n\log n)$算法 分而治之

- 分：递归
- 治：合

#### 1.3.3 最大子列和问题 $O(N)$ 算法 在线处理

```c++
int MaxSubseqSum4(int A[], int N)
{
    int ThisSum, MaxSum;
    int i;
    ThisSum = MaxSum = 0;
    for (i = 0; i < N; i++)
    {
        ThisSum += A[i];
        if (ThisSum > MaxSum)
        {
            MaxSum = ThisSum;
        }
        else if (ThisSum < 0)
        //重点，由于当前子列和是负值，后面继续扫描肯定比没有算当前子列和的后面单独扫描小，因此当前子列和清零，前面被抛弃重新计算
        {
            ThisSum = 0;
        }
    }
    return MaxSum;
}
```

- **在线**意为每输入一个数据进行即时处理，在任一地方中止输入，算法都能正确给出当前的解

## 第二章 线性结构

### 2.1 线性表及其实现

---

#### 2.1.1 多项式的表示

关键信息

- 项数$n$
- 系数$a_i$以及指数$i$

方法一 **顺序存储结构**直接表示

- 数组各分量对应多项式系数
- 指数对应数组下标
- 项数即为数组长度(存在系数为 0 的项)

_但对于指数过大，而项数不多的多项式 空间会造成巨大浪费_

方法二 **顺序存储结构表示非零项**

- 数组的各分量包含两个信息 系数和指数
- 系数为 0 的项不再表示
- 可采用**结构数组**
- 每一项**按照指数大小有序存储 方便计算**

方法三 **链表结构存储非零项**

基本相同的机理，只是物理位置存储不同

#### 2.1.2 线性表及顺序存储

_有序线性序列的组织与管理_

**线性表**

- **同类型**数据元素构成**有序序列**的**线性**结构
- 表中元素个数成为线性表的**长度**
- 线性表没有元素时，称为**空表**
- 表起始位置称为**表头**，表结束位置称为**表尾**

**抽象描述**

- 数据集 n 个元素组成的有序序列
- 操作集
  _建立空表
  按照位序返回元素
  查找元素第一次出现位置
  在某位序前插入新元素
  删除指定位序的元素
  返回线性表的长度_

**线性表的顺序存储**

- 利用数组的**连续存储空间顺序存放**线性表的各元素
- 抽象为一个拥有存储元素的数组成员(固定最大容量)和存放数组**目前存放最后元素下标**的索引的结构体

**相关操作的实现**

- **建立空表** 通过线性表结构体指针**在堆区开辟空间**，将结构体**最后索引成员赋值-1**，返回**堆区地址**
- **查找** 从**0 循环到最后索引成员**，找到返回索引，没找到返回-1 时间复杂度 O(n)
- **插入** 通过一次循环，将**要插入位置之后的元素全部向后移动一位**，再插入元素，更新最后索引成员，时间复杂度 O(n)
- **删除** 通过一次循环，将**要插入位置之后的元素全部向前移动一位**，更新最后索引成员，时间复杂度 O(n)

#### 2.1.3 链式存储及查找

**_不要求逻辑相邻的两个元素物理上相邻_**
_通过链建立起数据元素之间的逻辑关系_
_插入，删除**不需要移动数据元素**，只需要移动链_

- 每个单元抽象为含有**一个存储数据的元素**和**一个指向其他单元的指针**的结构体
- 但是查找，统计个数等操作较顺序表复杂

```c++
struct Lnode
{
    int number;
    Lnode *Next;
};
```

**相关操作的实现**

- **求表长** 通过指针变量等于头指针访问表头的 Next 指针，如果 Next 指针非空，则**更新指针变量为 Next，直到 Next 指针为空**，计数。时间复杂度 O(n)
- **按索引查找** 通过通过指针变量等于头指针访问表头的 Next 指针，如果 Next 指针非空且计数小于索引，则**更新指针变量为 Next，直到 Next 指针为空或计数等于索引**。时间复杂度 O(n)
- **按值查找** 同样的思想，通过通过指针变量等于头指针访问表头的 Next 指针，如果 Next 指针非空且单元值不等于查找值，则**更新指针变量为 Next，直到 Next 指针为空或找到查找值**。时间复杂度 O(n)
- **插入** 申请空间，**按索引找到要插入空间，新申请空间指向下一元素，修改前面元素指向新申请的空间**，注意插在头上的特殊处理。时间复杂度 O(n)
- **删除** 按索引查找到要删除处节点，**新定义一指针指向要删除节点，前一节点指向后一节点，delete 掉要删除节点**，注意插在头上的特殊处理。时间复杂度 O(n)

#### 2.1.4 广义表与多重链表

_二元多项式如何表示？_

对于一元多项式，我们采取链表，某一单元存储一项的系数和指数，对于二元多项式，我们可仍采用此方法，只不过 x 的系数变为了关于 y 的一个多项式->**链表原本存储系数的值变为了另一链表的头指针**

_这种表称为广义表_

_是线性表的一种推广_

**广义表中的元素既可以为单元素也可为另一广义表，可以通过 union 与标志位具体选择**

**多重链表** 节点可能同时隶属于*多个链*，此实例即为多重链表 _树、图中有广泛应用_

_广义表是一种多重链表_

### 2.2 堆栈 Stack

---

#### 2.2.1 什么是堆栈

**表达式计算**

- 中缀表达式 运算符位于两个运算数中间 $a+b*c-d/e$
- 后缀表达式 运算符位于两个运算数之后 $abc*+de/-$

_运算步骤_ 在遇到数时记住，在遇到符号时计算最后两个数

因此需要有一种储存方法，可以**顺序存储运算数，并在需要时倒序输出**

**先进后出**

- 具有一定的约束性的线性表
- 只能在一段**栈顶 Top**做插入删除
- 插入数据 **入栈**
- 删除数据 **出栈**

**操作集**

- 生成空堆栈，具有最大长度
- 判断当前堆栈是否已满
- **将元素入栈**push
- 判断堆栈是否为空
- **将元素出栈**pop

#### 2.2.2 堆栈的顺序存储实现

- 抽象为**一个一维数组**和一个记录**栈顶元素位置**的变量组成的结构体

**相关操作的实现**

- push 入栈操作 判断堆栈是否已满，**未满则栈顶元素位置 top 加一，数据放在数组末尾**
- pop 出栈操作 判断堆栈是否为空，**未空则栈顶元素位置 top 减一，返回数组末位元素**

**双向堆栈**

同一个数组，分别**由两头到中间入栈**，当 top 指针相遇时栈满

#### 2.2.3 堆栈的链式存储

- 采用单链表，叫链栈，插入和删除在链栈栈顶进行，TOP 指针即为 head 指针较为方便
- 栈顶在链头

**相关操作**

- 建立堆栈 在堆区申请空间，返回**这块空间的地址 s**;
- 判断堆栈是否为空 栈顶地址**s->next 是否为空**
- 入栈 push 新申请一块空间，并赋值，再**将申请空间的 next 指针指向 s->next，后将 s->next 指向申请空间**
- 出栈 pop 判断堆栈是否为空，未空，**s->next(出栈元素)赋给临时指针，s->next=临时指针->next，取出临时指针的值，delete 掉临时指针**

#### 2.2.4 堆栈应用 表达式求值

中缀表达式转化为后缀表达式，利用堆栈求值

**如何转化？**

- 运算数相对顺序不变
- 运算符号顺序发生变化
  需要存储“等待中”的符号 _堆栈_
  要将当前运算符号与“等待中”的最后一个运算符号比较
  **优先级更大则继续入栈等待，优先级低，则开始出栈**
- 注意，当左括号在**堆栈外，优先级最高，在堆栈内，优先级最低**，直到碰到右括号，开始出栈，直到左括号
- 同一优先级，先进栈的优先

时间复杂度 O(n)

同样需要堆栈存储

**其他应用**

- 函数调用及递归实现
- 深度优先搜索
- 回溯算法
- ...

### 2.3 队列 Queue

---

_排队 入队 出队_

#### 2.3.1 队列及其顺序储存实现

**队列**

- 具有一定操作约束的线性表 只能从一段插入，另一端删除
- 先进先出

**操作集**

- 生成具有最大长度的**空队列**
- 判断队列**是否已满**
- 将数据元素**插入**队列
- 判断队列**是否为空**
- 将队头元素从队列**删除并返回**

**顺序存储及实现**

- 抽象为一个由**一维数组**，和一个**记录队列头元素位置变量**front 和一个**记录队列尾元素位置**的变量 rear 组成的结构体
- 元素插入到 rear，同时 rear 自增，从 front 取出，同时 front 自增

**顺环队列** 当 rear 或 front 自增到头清零，形成环，空间充分利用

**但这种方法不能区分空还是满** 都会出现 front 和 rear 重叠

- 使用 n - 1 个空间
- 添加额外标记 size/tag

#### 2.3.2 队列的链式存储实现

_根据堆栈的链式存储，链表头可以执行删除添加操作，而链表尾只能执行添加操作，因此将 front 放在表头，rear 放在表尾_

**操作实现** 略

### 多项式加法运算

两个多项式分别以不带头结点的单向链表按照指数递减顺序排列各项

- 两指针指向第一个节点
- 比较指数，进行操作

## 第三章 树与二叉树

### 3.1 树与树的表示

---

_层次关系_

- 人类社会家谱
- 社会组织结构
- 图书信息管理

**这种层次结构称之为树**

_层次组织在管理上有更高效率_

_如 查找_ **给定某个关键字，从集合中找出与关键字相同的记录**

- 静态查找 集合中**记录固定**，无插入和删除操作，只有查找
- 动态查找 集合中**记录动态变化**，除查找外，还可能发生插入删除

#### 3.1.1 顺序查找

_静态查找在数组中的查找方法_

**哨兵**

- 事先在数组**预留循环末位置，值赋为要查找值**，这样省去一个循环终止条件，云鬟终止条件找到值即可
- 查找成功返回**单元下标**，不成功返回**哨兵下标**(一般为 0)
- O(n)

#### 3.1.2 二分查找

- 先决条件**有序存放**
- 放置于**数组中**

描述

1. 设置左右边界坐标
2. 开始循环 终止条件是**右侧边界坐标小于左侧**
3. 循环中计算中间元素坐标 **根据中间元素和查找值的关系，更新左右边界或 返回中间元素坐标(找到)，程序结束**
4. 退出循环后(即未找到) 程序结束

**时间复杂度 log(n)**

**二分查找判定树**

_11 个元素_

6
3(6) 9(6)
1(3) 4(3) 7(9) 10(9)
2(1) 5(4) 8(7) 11(10)

_每个节点元素要查找的次数恰巧是该节点所在层数_

- n 个节点的**判定树深度** $[log_2n]+1$
- 在这个例子平均查找次数为 3

#### 3.1.4 树 Tree 的定义和术语

**定义**

- n 个节点构成的有限集合。
- n = 0 时称为空树
- 对于任一棵非空树，具备以下性质
  树中有一个称为**根 root**的特殊节点，用 r 表示
  其余节点可分为**m 个互不相交的有限集**$T_1$-$T_m$,每个集合本身又是一棵树，称为原来树的**子树**

**特点**

- 子树是**不相交**的
- 除了根结点，**每个结点有且只有一个父节点**
- 一棵 N 个结点的树有**N - 1 个边**

**基本术语**

1. **结点的度** **结点**的子树个数
2. **树的度** 树中**所有结点最大度数**
3. **叶结点** **度为 0**的结点
4. **父结点** 结点上方的结点
5. **子节点** 结点下方的结点
6. **兄弟节点** **同一父节点**的两个节点
7. **路径和路径长度** 一条通路叫做**路径**，路径上结点个数 - 1（边的个数）叫**路径长度**
8. **祖先节点** **父结点及以上**，（满足通路）
9. **子孙节点** **子节点即以下**，（满足通路）
10. **结点的层次** 根节点在第一层，再下第二，再下第三
11. **树的深度** **所有结点最大深度**

#### 3.1.5 树的表示

_数组表示困难_

_链表表示？_ 由于子节点个数未知，链表每个节点的结构不一

可以采用每个链表结点结构统一，都可以包含树的度数个子结点，不需要的指向 NULL，但会造成空间上的浪费

**长子-兄弟表示法**

- 树上每个结点结构统一 **FirstChild** **NextSibling** 两个指针域

_当用长子-兄弟表示法表示出的结构旋转->得到树_

- 每个结点有两个指针，一个向左一个向右
- 每个结点最多有两个子节点

称为**二叉树**

- 度为 2
- 一般的树可以采用**长子-兄弟表示法**转化为**二叉树**

### 3.2 二叉树 BinTree

---

#### 3.2.1 二叉树的定义和性质

**定义**

- 一个有穷节点的集合
- 这个集合可以为空
- 若不为空，则是由一根节点和称为左子树$T_L$和右子树$T_R$的两个**不交叉的二叉树**组成
- 度为 2

**五种形态**

1. 空
2. 只有节点
3. 有节点和左子树
4. 有节点和右子树
5. 有节点和两个子树

**与一般的度为 2 的树的区别是二叉树的子树由左右顺序之分**

**特殊二叉树**

- **斜二叉树** 整个树的任意节点只有左子树或只有右子树 **线性结构**
- **完美二叉树**（满二叉树） 每个结点都有两个子节点
- **完全二叉树** 和完美二叉树比较，允许缺掉最后一部分叶节点（按从左至右顺序）

**二叉树重要性质**

- 第$i$层最多有$2^{i-1}$个节点
- 深度为 k 的二叉树有最大节点总数为$2^k-1$
- 对任意非空二叉树$T$，有两个子节点的节点比叶节点少一个

**操作集**

- 判别 BT 是否为空
- **遍历**，按顺序访问每个结点
- 创建一个二叉树

**常用遍历**

- 先序 根 左子树 右子树
- 中序 左子树 根 右子树
- 后序 左子树 右子树 根
- 层次遍历 从上到下，从左到右

#### 3.2.2 二叉树的存储结构

**顺序结构**

- **完全二叉树** 从上到下，从左到右编号，顺序存储
  非根节点的父节点在$[i/2]$
  结点的左子节点序号为$2i$(若$2i > n$没有左子节点)
  结点的右子节点序号为$2i$(若$2i > n$没有右子节点)
- **一般二叉树** 补齐成完全二叉树
  _会造成空间浪费_

**链式存储**

- Left Data Right 两个指针域一个数据域
- 无子节点指向 NULL

### 3.3 二叉树的遍历

---

#### 3.3.1 先序中序后序遍历

**先序遍历**

1. （若指向根节点指针不为 NULL）访问根结点数据
2. 先序遍历其左子树
3. 先序遍历其右子树

_递归实现_

实现结果 从左到右遍历到每一通路，若后面通路上有前面通路遍历过的结点则不遍历（每个结点只一遍）

**中序遍历**

1. （若指向根节点指针不为 NULL）中序遍历其左子树
2. 访问根结点数据
3. 中序遍历其右子树

实现结果 先左子树再中间再右子树分析

**后序遍历**

1. 后序遍历其左子树
2. 后序遍历其右子树
3. （若指向根节点指针不为 NULL）访问根结点数据

实现结果 先左子树再右子树再中间分析

**巧妙的实现结果**

- 围绕一棵二叉树绕一个圈子
- 根结点左侧为入口，逆时针
- 每个结点都有三次碰到机会
- 第一次碰到就遍历出的为先序
- 第二次为中序
- 第三次为后序

#### 3.3.2 中序非递归遍历

_使用堆栈_

**步骤**

1. 入栈头结点
2. 并向左边走（_按照上节提过的巧妙实现_），入栈碰到的结点，重复，直到走到左边底，出栈一个元素
3. 尝试往右走
4. 1 若此处有元素则入栈，跳转至 2
   2 若此处无元素，出栈一个元素，退至父节点，跳转至 3
   3 若此处元素已经访问过，退至父节点，跳转至 3

- 中序在元素出栈时输出
- 先序在元素入栈时输出

#### 3.3.3 层序遍历

_核心问题 二维结构的线性化_

**队列实现**

1. 头节点入队
2. 访问队列中队首的左子节点，入队
3. 访问队列中队首的右子节点，入队
4. 出队

## 第四章 树的应用

### 4.1 二叉搜索树

---

#### 4.1.1 二叉搜索树及查找

_静态查找 二分查找_

_动态查找 二叉搜索树(二叉排序树、二叉查找树)_

_查找删除较线性结构方便_

_比数据大的放在左子树，比数据小的放在右子树_

**定义**

- 根节点值大于左子树所有元素
- 根节点值小于右子树所有元素
- 左右子树**同样是二叉搜索树**

**二叉搜索树操作的特别函数**

- 查找到元素 X，返回所在节点的地址
- 查找到最小元素的地址
- 查找到最大元素的地址

**查找元素**

- 元素比节点大，节点更新为右子树节点，重复
- 比节点小，节点更新为左子树节点，重复
- 直到元素等于节点，返回节点地址

**查找最小最大** 一直往左/右走

#### 4.1.2 二叉搜索树的插入

_要保证插入后仍为二叉搜索树_

**方法**

- 重复比较插入数据和头节点
- 比节点数据大，插在右子树
- 比节点数据小，插在左子树
- 直到树空

### 4.2 平衡二叉树

---

#### 4.2.1 平衡二叉树的概念

_不同的插入次序会影响树的形状和深度，进而影响树的查找效率_

_左右及子树高度差大致相同的二叉树_

**平衡因子 BF** 左子树高度-右子树高度

**平衡二叉树 AVL** **任一节点**的平衡因子不超过 1

**效率为 O(logn)**

#### 4.2.2 平衡二叉树的调整

- **RR 插入** 插入在被破坏节点的右子树的右子树上 <br> 解决方式 **RR 旋转** 将**被破坏节点**变为**其原右子节点**的**左子节点**（_如被破坏节点有原父节点，则原父节点直接连在其原右子节点_），再把**其原右子节点**的**原左节点**挂在**被破坏节点**的**右子节点**
- **LL 插入** 插入在被破坏节点的左子树的左子树上 <br> 解决方式 **LL 旋转** 将**被破坏节点**变为**其原左子节点**的**右子节点**（_如被破坏节点有原父节点，则原父节点直接连在其原左子节点_），再把**其原左子节点**的**原右节点**挂在**被破坏节点**的**左子节点**
- **LR 插入** 解决方式 **LR 旋转**
- **RL 插入** 解决方式 **RL 旋转**

## 第五章 堆

### 5.1 堆

---

#### 5.1.1 堆的概念

_优先队列 排序不是进入队列的顺序，而是元素的优先级_

_通过完全二叉树进行存储_

**特性**

- 结构性 用**数组表示的完全二叉树**
- 有序性 任一节点的**关键字**是其子树所有结点的**最大/最小值**(最大堆，最小堆)

_从根节点带任一节点路径上结点关键字序列有序_

**常用操作**

- 建立空最大堆
- 判断最大堆是否满
- 将元素压入最大堆
- 判断最大堆是否为空
- 返回最大堆中最大元素

#### 5.1.2 堆的插入

_将新增节点插入从其父节点到根结点的有序序列中 o(logn)_

```c
// 最大堆插入操作
void Insert(MaxHeap H, int item)
{
    int i;
    if (IsFull(H))
    {
        printf("最大堆已满");
        return;
    }
    i = ++(H->size); // 更新Size,同时将i赋值为新的Size
    // 反复比较新增元素和父节点，把小的父节点挪下去
    for (; H->arr[i / 2] < item; i /= 2)
    {
        H->arr[i] = H->arr[i / 2];
    }
    H->arr[i] = item;
}
```

#### 5.1.3 最大堆的删除

_取出并删去根节点元素_

_取出，删去根节点,将最后的结点挪到根节点，反复比较这个元素和其最大的儿子，满足条件调换位置_

```c
// 删去取出堆顶
int DeleteMax(MaxHeap H)
{
    int Parent, Child;
    int MaxItem, tmp;
    if (ISEmpty(H))
    {
        // 堆空返回哨兵
        return H->arr[0];
    }
    // 取出最大值
    MaxItem = H->arr[1];
    // tmp赋为最后一个节点 同时size更新
    tmp = H->arr[(H->size)--];
    // 找到tmp放的位置 parent来指示这个位置 最开始在头结点
    for (Parent = 1; Parent * 2 <= H->size; Parent = Child)
    {
        // 找到左儿子
        Child = Parent * 2;
        // 左儿子和右儿子
        if ((Child != H->size /*没有左儿子?*/) && (H->arr[Child] < H->arr[Child + 1]))
        {
            Child++;
        }
        // 判断要插入元素和较大儿子的大小
        if (tmp >= H->arr[Child])
        {
            break;
        }
        else
        {
            H->arr[Parent] = H->arr[Child];
        }
    }
    H->arr[Parent] = tmp;
    return MaxItem;
}
```

#### 5.1.4 最大堆的建立

- 法一:不断插入(o(nlogn))
- 法二:先将 N 个元素顺序存入完全二叉树，后调整成堆 <br> 调整的方法即为堆去顶后的调整方案:左右子树都是堆的情况下，调整顶节点<br>从下到上递归实现(o(log(n)))

#### 5.1.5 最大堆操作合集

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXDATA 100000

// 最大堆结构体 MaxHeap为最大堆指针类型
typedef struct HeapStruct
{
    int *arr;
    int size;
    int capacity;
} *MaxHeap;

// 创建最大堆 该堆的最大规模 Maxsize
MaxHeap Create(int Maxsize)
{
    MaxHeap H = malloc(sizeof(struct HeapStruct));
    // 由于哨兵占一个位置，所以加1
    H->arr = malloc((Maxsize + 1) * sizeof(int));
    H->size = 0;
    H->capacity = Maxsize;
    // 哨兵 可能的最大值
    H->arr[0] = MAXDATA;
    return H;
}

// 判断是否堆满
int IsFull(MaxHeap H)
{
    if (H->size == H->capacity)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

// 判断是否堆空
int ISEmpty(MaxHeap H)
{
    if (H->size == 0)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

// 最大堆插入操作
void Insert(MaxHeap H, int item)
{
    int i;
    if (IsFull(H))
    {
        return;
    }
    i = ++(H->size); // 更新Size,同时将i赋值为新的Size
    // 反复比较新增元素和父节点，把小的父节点挪下去
    for (; H->arr[i / 2] < item; i /= 2)
    {
        H->arr[i] = H->arr[i / 2];
    }
    H->arr[i] = item;
}

// 删去取出堆顶
int DeleteMax(MaxHeap H)
{
    int Parent, Child;
    int MaxItem, tmp;
    if (ISEmpty(H))
    {
        // 堆空返回哨兵
        return H->arr[0];
    }
    // 取出最大值
    MaxItem = H->arr[1];
    // tmp赋为最后一个节点 同时size更新
    tmp = H->arr[(H->size)--];
    // 找到tmp放的位置 parent来指示这个位置 最开始在头结点
    for (Parent = 1; Parent * 2 <= H->size; Parent = Child)
    {
        // 找到左儿子
        Child = Parent * 2;
        // 左儿子和右儿子
        if ((Child != H->size /*没有左儿子?*/) && (H->arr[Child] < H->arr[Child + 1]))
        {
            Child++;
        }
        // 判断要插入元素和较大儿子的大小
        if (tmp >= H->arr[Child])
        {
            break;
        }
        else
        {
            H->arr[Parent] = H->arr[Child];
        }
    }
    H->arr[Parent] = tmp;
    return MaxItem;
}

int main()
{
    MaxHeap heapPtr = Create(10);
    Insert(heapPtr, 2);
    Insert(heapPtr, 5);
    Insert(heapPtr, 4);
    printf("%d\n", DeleteMax(heapPtr));
    return 0;
}
```

### 5.2 哈夫曼树和哈夫曼编码

---

_根据节点不同的查找频率构造更有效的搜索树_

#### 5.2.1 哈夫曼树的定义

**带权路径长度**

- 二叉树有 n 个**叶节点**，每个叶节点各自权值$w_k$，从根节点到每个叶节点各自长度$l_k$,则每个叶节点的带权路径之和(WPL) = 从 1 到 n 求和$w_kl_k$

**哈夫曼树(最优二叉树)** WPL 最小的二叉树

#### 5.2.2 哈夫曼树的构造

**步骤**

1. 首先将元素按照权值排好
2. 每次将权值最小的两颗二叉树合并为一颗:合并后权值为合并前权值的和
3. 取出权值最小可以通过堆来完成，合并后插入堆里

O(NlogN)

**特点**

- 没有度为一（只有单子树）的结点,_因为是两两左右配对合并而来_
- n 个叶节点的哈夫曼树共有 2n-1 个节点 _二叉树性质 n2 = n0 - 1_
- 哈夫曼树的任意非叶节点的左右子树交换后，仍为哈夫曼树 _构造原理_
- 同一组权值，可能存在多课不同构的 WPL 相同的哈夫曼树

#### 5.2.3 哈夫曼编码

_如何避免二义性使用不等长编码？_

**前缀码** 任意字符的编码都不是另一字符编码的前缀，即可避免这一问题

**编码的二叉树表示** 左子节点为 0，右子节点为 1。当所有字符都在二叉树的叶节点上，就不会发生前缀的现象，不会出现二义性。

_综上，即可简单的将权重当作叶节点，构造哈夫曼树，完成编码_

### 5.3 集合

---

_集合的运算 交 并 补 差 判定一个元素是否属于一个集合_

_并查集 合并两个集合 查找元素是否属于这个集合_

#### 5.3.1 集合的表示和查找

_可以使用树结构表示集合，树的每个结点代表一个集合元素_

_这种树由孩子指向父亲_

**通过数组存储**

- 每个数组包含这一问题中涉及到的全部集合

- 数组中每个元素由两个域组成:data-自身的*信息* parent 其父元素的*下标*（-1 代表其没有父元素）

**查找操作**

_找到集合数组中某一元素的树根(这个元素属于哪个集合)_

1. 在数组中查找到查找的元素
2. 获取查找元素的父元素索引
3. 通过父元素索引再访问其父元素，获取父元素的 parent
4. 以此类推，直到某一元素的 parent 为 0，即为树根

#### 5.3.2 集合的并运算

_将某两个元素的所属集合并在一起_

1. 找到这两个元素的根节点
2. 将其中一个根节点的 parent 设置为另一个根节点的下标

_集合不断合并之后可能会导致高度过高，进而影响 find 查找，因而可以尽量把高度小的树合并在高度大的树_

_需要新增一个数据记录各集合高度(粗略:大小)，但只对根节点添加这个数据即可，不然会造成空间的浪费_

_可以把根节点的 parent 改为-元素个数，代表集合大小_

## 第六章 图

_最短路径问题_

### 6.1 图的定义

---

_表示多对多的关系_

_线性表和树都是图的一种特殊情况_

**顶点** _通常用 V 表示顶点集合_

**边** _通常用 E 表示边的集合_

_边是顶点对_

- (v,w)表示这条边无向，双向通行
- <v,w>表示从 v 指向 w 的边，单行线
- 图中不考虑重向(两个顶点中多条边),自回路(一条边的两个顶点为同一个)

**类型名称** 图 Graph

**数据对象集** G(V,E)由非空有限顶点集 V 和一个有限边集合 E 组成

**常见操作集**

- 建立并返回图
- 将 v 插入 G
- 将 e 插入 G
- 从顶点 v 出发深度优先遍历图 G
- 从顶点 v 出发宽度优先遍历图 G
- 计算图 G 中顶点 v 到其他顶点的最短距离
- 计算图 G 的最小生成树

**常见术语**

- 无向图 所有边无所谓方向
- 有向图 边可能双向也可能单向
- 权重 给每个边一个数字（长度等意义）
- 带权重的图 网络

### 6.2 邻接矩阵表示法

---

**原理**

- N 个顶点，从 0-N-1 编号
- 一个二维数组`G[N][N]`
- <$v_i$,$v_j$>连通->`G[i][j] = 1`
- 否则为 0

_对于无向矩阵的存储，会浪费一半的空间_

_采取一维数组的存储方式，仅存在二维数组中可能有效的一半元素（下三角）（包括对角线）_

_新的元素索引和边对应的关系，可以通过等差数列求和的换算一一对应_

- 而对于网络，边的权重可以把元素赋值即可

**邻接矩阵的好处**

- 直观，易理解
- 便于检查任意两对顶点间是否有边
- 方便找任意顶点的所有'邻接点'(有边直连的点) <br>无向:沿着下三角的两条直角边上对应点，分别查找该行列上 1 的位置 <br>有向:类似，查找矩阵的对应点的行列
- 方便计算任意点的'度'(从该点出发的边数:出度，反之入度) 和上一条一样

**缺点**

- 点多边少时(稀疏图) 浪费空间时间 _稠密图(尤其完全图:n 个顶点，两个顶点之间都有一条边)很合算_

### 6.3 邻接表表示法

---

**原理**

- G[N]指针数组
- 数组中每个指针对应一个顶点对应一个链表，只存非 0 元素
- 每个顶点的代表指针指向的链表，存放这个顶点连接点的编号

_不仅要存编号，还要存指针，网络还要存权重_

_因此只有稀疏的情况下，邻接表表示法才合算_

**特点**

- 方便找到任意顶点的所有临接点
- 在稀疏情况下节约空间
- 方便计算无向图的度
- 方便计算有向图的出度(要构造逆邻接表才方便计算入度)
- 不方便检查任意一堆顶点间是否存在边

### 6.4 图的遍历

---

_访问图中的每一个顶点（不重复）_

#### 6.4.1 DFS 深度优先搜索

_死脑筋 只要有没有遍历到的就一直深入探索_

_一条路上四周都探索过，原路退回上一节点_

_从入口入，从入口出_

_函数的递归调用_

_树先序遍历的推广_

- 邻接表表示法 O(N + E)
- 邻接矩阵表示法 O(N^2)

#### 6.4.2 BFS 广度优先搜索

_树层序遍历的推广_

_通过队列实现_

_元素出队时，把它相邻的未搜索过的下一元素入队_

- 邻接表表示法 O(N + E)
- 邻接矩阵表示法 O(N^2)

_两种遍历的各有特点 如迷宫的出口不同，生效的效率也不同_

### 6.5 图不连通

---

**连通** 如果从 v 到 w 有一条(无向)路径，则称 v 和 w 连通

**路径** 一系列顶点的集合，其中任一对相邻的顶点都有图中的边。从$v$出发最终可以走到$w$。路径的长度是路径中的变数，带权则为各边权重之和。如果 v 到 w 之间所有顶点都不同，则称简单路径

**回路** 起点等于终点的路径 _一个路径上有回路，则不是简单路径_

**连通图** 图中任意两顶点均连通

**连通分量** 无向图的**极大**(不是最大，可能多个)连通子图 <br> 极大定点数:
再加一个顶点就不连通了 <br> 极大边数: 包含子图中所有顶点相连的所有边

**强连通** 有向图中顶点 v 和 w 之间**存在双向路径**(正反向路径不一定同一条)，则称 v 和 w 强连通

**强连通图** 有向图中任意两定点均强连通

**强连通分量** 有向图的极大强连通

_DFS/BFS 遍历不连通图 首先图上遍历所有点，如果某点没有访问过 DFS 这个点(会递归或者循环地访问这个点所在的连通分量)_

## 第七章 最短路径问题

_最便宜，最快，最近 根据权重不同_

_在网络中，求两个不同顶点之间的所有路径中，边的权值之和**最小**的那一条路径_

**源点** 第一个顶点

**终点** 最后一个顶点

- 单源最短路径 从固定源点 求到其他所有顶点的最短路径
- 多源最短路径 求任意两定点间的最短路径

### 7.1 无权图的单源最短路算法

- 按照非递减顺序找出到各个顶点的最短路<br>从源点出发，每次找到临接点->到这几个临接点的最短路:1，再从临接点出发，找它们的临接点(若有之前已找到的就跳过)->到临界点的临界点最短路:2 以此类推 -- BFS 的思想
- _邻接表表示法 o(V+E)_

### 7.2 有权图的单源最短路算法

- 按照非递减顺序找出到各个顶点的最短路

## 第八章 排序算法

_简单起见，讨论正整数从小到大的排序 10000 元素以上规模_

`void X_Sort(ElementType A[], int N)`

_讨论基于比较的排序_

_内部排序 内存空间足够大_

**稳定性** 任意两个相等的数据，排序前后的相对位置不发生改变 稳定, 否则不稳定

_没有一种排序在任何情况下都是最好的_

### 8.1 冒泡排序

`void Bubble_Sort(ElementType A[], int N)`

---

**步骤**

1. 每次内层循环**把最大的移到最后** ，_也就是一次排序_: 依次**从最前端开始**，遇到**前面元素比后面元素大，交换位置**
2. 第一次内层循环**从第一个和第二个元素比较，到倒数第二个和最后一个元素比较**
3. 第二次内层循环，依旧从第一个和第二个元素开始比较，**到倒数第三个和倒数第二个元素**比较结束
4. 依次类推，最后一次内层循环只比较第一个和第二个元素，**本次内循环只循环一次**
5. **外层循环**用来**控制每次内层循环的终点**

**一些改进点和做法**

- 当程序在中间排好序时，不会中止:可以**在内循环（一次排序）开始前**，初始化一个 Flag，当排序中**发生交换的情况，修改 flag**，当**内循环结束，判定 Flag 有没有修改**，决定是否中止

**时间复杂度**

- 最好情况: 只需要内循环扫描一次，即可通过 Flag 判断跳出 O(n)
- 最坏情况: 逆序 O(n^2)

**特点**

- 排序简单，但时间复杂度高
- 不仅可以数组中排序，也可以进行链表中排序
- 稳定(只有当前>后时交换，等于时不交换)

**实现**

```c
#define ElementType int

void Bubble_Sort(ElementType A[], int N)
{
    // 外层循环，控制每次排序的终止值
    // 第一次循环从第一个和第二个比较循环到倒数第二个和倒数第一个 循环 n - 1次，因此 p 的起始值为 n - 1
    // 最后一次循环 内层循环只循环一次 因此 p 的中止值为 1
    for (int p = N - 1; p > 0; p--)
    {
        // 一趟排序 内循环
        int Flag = 1; // 排序是否成功标志,如果一次排序(内循环)中没有更改 Flag ，代表已排好
        for (int i = 0; i < p; i++)
        {
            // 一次排序中每个步骤：比较前后，大的放后面
            if (A[i] > A[i + 1])
            {
                Flag = 0;
                int temp = A[i];
                A[i] = A[i + 1];
                A[i + 1] = temp;
            }
        }
        // 在本次内循环，Flag 始终为 1 ，已排好，结束
        if (Flag)
        {
            break;
        }
    }
}
```

_数组排序测试 main 函数_

```c
int main()
{
    int arr[] = {3, 5, 2, 6, 3, 7};
    for (int i = 0; i < sizeof(arr) / sizeof(int); i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
    Bubble_Sort(arr, sizeof(arr) / sizeof(int));
    for (int i = 0; i < sizeof(arr) / sizeof(int); i++)
    {
        printf("%d ", arr[i]);
    }
    return 0;
}
```

使用时修改排序函数名即可

### 8.2 插入排序

`void Insertion_Sort(ElementType A[], int N)`

---

**步骤**

1. 每次内循环(排序)，**把要排序的数字，拿出来**，开始循环: _和前面的数字进行比较: 从后到前，如果要排序的数字比在比较的数字小，比较的数字后移一位，继续和再前面的数字比较_
2. 直到全比较完，或者找到比要排序数字大的值，把要排序数字放在之前移出来空位上，**在落位时，需要知道最后一次内层比较的元素位置，因此要在外循环中就声明**
3. **内层**循环控制**外层找到数字**每次要比较的元素
4. **内层第一次**找到的是**外层确定元素的前一个**
5. **内层最后一次**找到的是**数组中第一个元素**
6. **外层**循环控制**找到每次排序的数字**
7. **外层第一次**找到的 是**第二个元素**
8. **外层最后一次**找到的 是**最后一个元素**

**时间复杂度**

- 最好情况 顺序 只需要外循环确定每次摸到的元素，插入直接放就行，因此是 O(n)
- 最坏情况 逆序 O(n^2)

**特点**

- 程序简单
- 稳定，外循环选择元素和内循环比较元素相等时，相对顺序不动

**实现**

```c
#define ElementType int

void Insertion_Sort(ElementType A[], int N)
{
    // 外层循环 每次找到本次插入的元素 从第二个开始，一直到最后
    for (int p = 1; p < N; p++)
    {
        // 取出本次插入的元素
        int temp = A[p];
        // 内层循环 每次找到要比较的元素 从插入元素的前一个开始 一直到第一个
        // 结束条件为找遍所有元素 或者 前面找到元素小于或者等于插入元素
        int i; // 循环结束后，要知道空位在哪，因此要提前声明i
        for (i = p - 1; i > -1 && A[i] > temp; i--)
        {
            // 查找元素应在插入元素后面，把查找元素后移一位，留出空位
            A[i + 1] = A[i];
        }
        // 插入元素安插在空位上
        //注意 由于是 i-- 后退出循环的，故之前的空位 A[i] 应变为 A[i + 1]
        A[i + 1] = temp;
    }
}
```

_插入排序和冒泡排序，每次只交换相邻元素，一次只能交换一个逆序对_

_逆序对: i < j,而 A[i] > A[j]_

_寻求一次交换不止一个逆序对的算法_

### 8.3 希尔排序

`void Shell_Sort(ElementType A[], int N)`

---

**步骤**

1. 对数组中元素**分一定间隔**进行**插入排序**，缩减一定的逆序对，减小间隔，重复，最后一次为**1 间隔，也就是普通的插入排序**
2. 分为**三层循环**，最外层循环控制间隔的大小，起始值通常为 N 的一半，终止值一定为 1，而变化的过程有很多种，最初每次变化为原来的一半，但是这种**增量序列**效率不高
3. 内两层循环为**普通的插入排序**，但是在**第二层**循环中，**最开始要找的元素不在是第 2 个，而是第 1+间隔 D 个**
4. **最内层**循环**原本涉及到加减 1 的地方都为 D**

**时间复杂度**

- 根据增量序列的不同而不同，最开始的减半序列效率很低为 O(n^2)（最好的情况也是如此）
- 在相邻数互质的情况好很多，有 O(n^(3/2))和 O(n^(5/4))等

**实现**

```c
#define ElementType int

void Shell_Sort(ElementType A[], int N)
{
    // 外层循环 控制间隔 D
    // 初始值为 N/2 最终为 1 .
    // 增量序列每次变为之前的一半
    for (int D = N / 2; D > 0; D /= 2)
    {
        // 第二次 和插入排序类似 控制本次插入的数据
        // 初始值为 D
        for (int p = D; p < N; p++)
        {
            int tmp = A[p];
            int i;
            // 最内层循环 控制要查找对比的数据 之前的 1 都换为间隔 D
            for (i = p - D; i > -D && tmp < A[i]; i -= D)
            {
                A[i + D] = A[i];
            }
            A[i + D] = tmp;
        }
    }
}
```

### 8.4 选择排序

`void Selection_Sort(ElementType A[], int N)`

---

**步骤**

1. 每一次**内循环**从未排序位置(后面)一直到最后，**找到最小值*位置***
2. 将**最小值**和未排序部分的第一个元素交换
3. **外层循环 控制指示未排序位置** 从 0 开始 最后一次值为 N - 2
4. **内层循环 即一次查找** 从外层指示的未排序位置开始，一直到最后

**时间复杂度** O(n^2)

**实现**

```c
#define ElementType int

void Selection_Sort(ElementType A[], int N)
{
    // 外层循环 指示未排序位置（后面） 初始值为 0 最后一次为 n - 2
    for (int p = 0; p < N - 1; p++)
    {
        int minP = p; // 初始化最小值位置为未排序位置第一个
        // 内层循环 查找到未排序位置的最小值
        for (int i = p; i < N; i++)
        {
            if (A[i] < A[minP])
            {
                minP = i;
            }
        }
        // 将最小的和未排序位置第一个元素交换
        int tmp = A[minP];
        A[minP] = A[p];
        A[p] = tmp;
    }
}
```

### 8.5 堆排序

`void Heap_Sort(ElementType A[], int N)`

---

_后续补充_

### 8.6 归并排序

---

#### 8.6.1 有序子列归并

_核心 两个有序子列的归并_

**两个有序子列归并的步骤**

1. 准备好**三个数组**（两个有序子列，一个归并后数组）
2. 准备好**三个指针**指向这三个数组的首地址
3. 类似于多项式的相加，每次比较指向两个有序子列的指针所指的值，把**较小的存入归并数组的指针指向的值**
4. 较少值所属数组的**指针自增**，归并数字的指针自增

- _这里的数组和指针换成其它诸如此类可以产生同等功能的替代物均可_

**有序子列归并时间复杂度** O(n)

**有序子列归并的实现**

```c
#define ElementType int

// 待排序数组 临时数组 待排序数组中左有序序列起始位置 右有序序列起始位置 右有序序列终止位置(右序列最后一元素)
void Merge(ElementType A[], ElementType TmpA[], int L, int R, int RightEnd)
{
    int LeftEnd = R - 1;                // 计算出左侧终止位置
    int Tmp = L;                        // 存放临时结果的数组起始位置
    int NumElements = RightEnd - L + 1; // 最终数组中应有的元素个数
    // 指向左右序列元素的“指针”没有超过终止位置
    while (L <= LeftEnd && R <= RightEnd)
    {
        // 左序列在放置的元素不比右序列在放置的元素大
        if (A[L] <= A[R])
        {
            // 放置左序列的元素，自增两个指针
            TmpA[Tmp++] = A[L++];
        }
        else
        {
            // 放置右序列的元素，自增两个指针
            TmpA[Tmp++] = A[R++];
        }
    }
    // 左序列未到尽头 而有序列到了 开始直接放置做左列
    while (L <= LeftEnd)
    {
        TmpA[Tmp++] = A[L++];
    }
    while (R <= RightEnd)
    {
        TmpA[Tmp++] = A[R++];
    }
    // 搬运到待排序数组
    // i只控制了循环次数，要用 RightEnd 控制复制位置！！
    for (int i = 0; i < NumElements; i++, RightEnd--)
    {
        A[RightEnd] = TmpA[RightEnd];
    }
}
```

#### 8.6.2 归并排序的递归算法

_思想 数组的分而治之_

**步骤**

1. 将数组**一分为二**,两个子序列排好序
2. 通过**两个有序子列的归并算法**,使得整个序列有序
3. **子序列**的排序仍通过上述两步进行，**递归实现**
4. 对于函数的接口优化，额外声明一个**调用函数，只在此处开辟一次 TmpA**，_否则递归的“递”过程使用大量空间！_ 传入上述功能函数

**时间复杂度** O(NlogN) 无论好坏都是

**特点** 稳定

**实现**

```c
// 递归归并排序 功能函数 排序数组 临时数组 排序起始点 排序终点(存在元素)
void Msort(ElementType A[], ElementType TmpA[], int L, int RightEnd)
{
    int Center;
    // 元素的个数大于1，有排序价值
    if (L < RightEnd)
    {
        // 由于左侧至少比右侧小 1 ，Center 总大于等于 L
        // 在 Center 等于L时，Center + 1 等于 RightEnd ,会再递一次到达终点
        // 由于 Center 和 Center + 1 的关系，总会归，不会出现死循环
        Center = (L + RightEnd) / 2;
        Msort(A, TmpA, L, Center);               // 左子列归并排序
        Msort(A, TmpA, Center + 1, RightEnd);    // 右子列归并排序
        Merge(A, TmpA, L, Center + 1, RightEnd); // 两个有序子列的归并排序
    }
}

// 归并排序接口 调用函数 在次数调用功能函数
void Merge_Sort(ElementType A[], int N)
{
    // 在接口仅声明一次临时数组，传入递归功能函数即可
    ElementType *TmpA = malloc(sizeof(ElementType) * N);
    Msort(A, TmpA, 0, N - 1);
    // 注意 malloc 一定搭配 free
    free(TmpA);
}
```

#### 8.6.3 归并排序的非递归算法

_后续补充_

### 8.7 快速排序

_最常用到 大规模随机数据_

_思想 分而治之_

**步骤**

1. 在序列中通过某种方法**选取出一个合适的主元**
2. 把其余数据**按照和主元的大小关系分为两个子集**
3. 对这**两个子集递归**地重复上两步，**主元放在小子集后，大子集前，不会再动**

**时间复杂度** 最好 O(NlogN) 最坏 O(n^2)

**主元的选取**

_头中尾中位数法_

```c
#define ElementType int

// 中位数函数 获取序列中左中右三个元素的中位数 并将最小放左 中位数和最大放在倒数两位
// 序列所在数组 序列开始索引 序列终止索引
ElementType Median3(ElementType A[], int Left, int Right)
{
    int Center = (Left + Right) / 2;
    // 冒泡排序 使三个位置元素有序
    if (A[Left] > A[Center])
    {
        ElementType tmp;
        tmp = A[Left];
        A[Left] = A[Center];
        A[Center] = tmp;
    }
    if (A[Center] > A[Right])
    {
        ElementType tmp;
        tmp = A[Center];
        A[Center] = A[Right];
        A[Right] = tmp;
    }
    if (A[Left] > A[Center])
    {
        ElementType tmp;
        tmp = A[Left];
        A[Left] = A[Center];
        A[Center] = tmp;
    }
    // Left Right Center仍指向左中右, 而指向元素发生改变,变得有序

    // 巧妙的优化 将此时 Center 指向的中位数和倒数第二个元素交换
    // 方便子集划分
    ElementType tmp;
    tmp = A[Center];
    A[Center] = A[Right - 1];
    A[Right - 1] = tmp;
    return A[Right - 1];
}

void Quicksort(ElementType A[], int Left, int Right)
{
    ElementType Pivot = Median3(A, Left, Right);
    if (Right - Left + 1 < 4)
        return;
    // 划分子列
    int i = Left;      // i 指向无需进行子列划分的序列头
    int j = Right - 1; // j 指向选择并放置好的主元
    for (;;)
    {
        while (A[++i] < Pivot)
            ; // 前指针指向在比主元小的情况不断自增，比主元大于等于停
        while (A[--j] > Pivot)
            ;
        if (i < j) // 前后指针都停止 没有交汇 调换前后指针指向
        {
            ElementType tmp = A[i];
            A[i] = A[j];
            A[j] = tmp;
        }
        else // 前后指针交汇，意味着子集划分以完成
        {
            break;
        }
    }
    // 主元归位 放置在交汇后前指针处 注意交换的是位置 不能想当然成值
    ElementType tmp = A[i];
    A[i] = A[Right - 1];
    A[Right - 1] = tmp;
    // 本次排序完成 递归两个子序列
    Quicksort(A, Left, i - 1); // 主元(位置i)左侧
    Quicksort(A, i + 1, Right);
}

void Quick_Sort(ElementType A[], int N)
{
    Quicksort(A, 0, N - 1);
}
```

**子集的划分**

1. 选择主元后，先前序列的**起始和终止位置无需考虑**，主元在**考虑序列的最后一位**
2. 在**考虑序列**的首位和倒数第二位(主元前)定义**两个指针**
3. **前指针**指向**小于主元，自增**，继续判断，直到前指针**指向大于等于**(_等于放在这里也考虑了复杂度的问题，很细节_)**主元，开始判断后指针**
4. 后指针执行**大于**主元，自增，继续判断，直到后指针指向**小于等于主元，交换前指针指向和后指针指向**，重新开始**判断前指针**
5. 如此下来，**前指针左侧都是小于主元的，后指针右侧都是大于主元的**，当两指针**交汇之后，前指针和后指针必定会停止**，此时不符合**大前提（前指针小于后指针）**，因此结束，子集划分完成
6. **交换主元和前指针的位置**，（_经过简单的证明，最后前后指针总会停在相邻位置，且结束前的最后一步一定是后指针的前移，因此要交换主元和后指针在最后移动前的元素(满足大于主元的第一个元素)，即交换主元和前指针_），**主元即保持不动(快速排序快的关键)，继续递归主元前后的两个子序列**

**快速排序的优化**

- 递归的问题 耗费大量系统堆栈
- 对于小规模数据 采用简单排序如插入排序
- 可以定义一个 Cutoff 阈值

**思想**

```c
ElementType Pivot = Median3(A, Left, Right);
// 划分子列
int i = Left;      // i 指向无需进行子列划分的序列头
int j = Right - 1; // j 指向选择并放置好的主元
for (;;)
{
    while (A[++i] < Pivot)
        ; // 前指针指向在比主元小的情况不断自增，比主元大于等于停
    while (A[--j] > Pivot)
        ;
    if (i < j) // 前后指针都停止 没有交汇 调换前后指针指向
    {
        ElementType tmp = A[i];
        A[i] = A[j];
        A[j] = tmp;
    }
    else // 前后指针交汇，意味着子集划分以完成
    {
        break;
    }
}
// 主元归位 放置在交汇后前指针处 注意交换的是位置 不能想当然成值
ElementType tmp = A[i];
A[i] = A[Right - 1];
A[Right - 1] = tmp;
// 本次排序完成 递归两个子序列
printf("%d\n", Pivot);
for (int i = 0; i < 6; i++)
{
    printf("%d ", A[i]);
}
printf("\n");
Quicksort(A, Left, i - 1); // 主元(位置i)左侧
Quicksort(A, i + 1, Right);
```

**实现**

```c++
void pai(int A[], int f, int b){
    int m = A[(f + b) / 2];
    swap(A[(f + b) / 2], A[f]);
    int i = f, j = b + 1;
    for(;;){
        while(A[++i] < m && i <= b);
        while(A[--j] > m && j >= f);
        if(i < j) swap(A[i], A[j]);
        else break;
    }
    swap(A[j], A[f]);
    if(f < j - 1) pai(A, f, j - 1);
    if(j + 1 < b) pai(A, j + 1, b);
}
```

### 第九章 二分查找、二分答案

**简介**

* 二分的适用条件在于*有序的序列*
* 时间复杂度`log(n)`

**模版**

```c++
while (l < r){
    int mid = l + r >> 1;	//(l+r)/2
    if (check(mid))  r = mid;    // check()判断mid是否满足性质
    else l = mid + 1;
}
```

```c++
while (l < r){
    int mid = l + r + 1 >> 1;	//(l+r+1)/2
    if (check(mid))  l = mid;
    else r = mid - 1;
}
```

**算法解析 以模板一为例**

```c++
#include <iostream>

using namespace std;

#define TARGET 7

int arr[] = {1, 2, 5, 6, 7, 8};

// 二分查找到 TARGET

// 判断目标值在当前查找的什么位置
// 在当前查找值左侧及本身位置 返回 true
// 在当前查找值右侧 返回 false
bool check(int mid){
    return arr[mid] >= TARGET;
}

int main(){
    // 初始化左右边界
    int l = 0, r = 5;
    // 二分模版一 序列中含有有多个 TARGET 时，返回左侧第一个 TARGET 的位置
    while(l < r){
        // 获取中间元素 当左右边界相邻时 取左边界
        // 目的是当最终 l 和 r 相邻时，mid 在 l 的位置
        int mid = (l + r) / 2;
        // TARGET 在左侧及当前位置 更新右边界至当前位置
        if(check(mid)) r = mid;
        // TARGET 在右侧 更新左边界至当前位置的右侧
        else l = mid + 1;
    }
    cout << l << '\n';
    return 0;
}
```

**对模板一和模版二的实例过程分析**

```
        T    
1 2 5 6 7 8
l         r
    m
      l   r
        m
      l r
      m
        E

        T
1 2 5 6 7 8
l         r
      m
      l   r
        m
        l r
          m
        E  

-----------------
    T
1 2 3 3 3 6 7 9
l             r
      m
l     r
  m
    l r
    m 
    E

        T
1 2 3 3 3 6 7 9
l             r
        m
        l     r
            m
        l r
          m
        E
```

**浮点二分**

```c++
while(r-l>1e-5) //需要一个精度保证
{
    double mid = (l+r)/2;
    // check 目标值在mid左为真
    if(check(mid)) r=mid; //或l=mid;
    else l=mid; //或r=mid;
}
```