# 从与非门到俄罗斯方块

[online-IDE](https://nand2tetris.github.io/web-ide/chip)

[课程地址](https://www.coursera.org/learn/build-a-computer/home/week/1)

[搬运中字地址](https://www.bilibili.com/video/BV1KJ411s7QJ)

## 0 绪论

### 简介

从底层的软硬一构建出一个完整的通用计算机

* 前阶段构建硬件部分
* 第二阶段基于构建出的硬件构建计算机的软件

### 本课程的思想 

* 计算机的内容丰富且冗杂 
    * 源文件中的文本是如何发挥作用的
    * 编译器是如何工作的
    * 在屏幕上打印是如何做到的？如何控制具体像素点的亮度
    * 为什么不需要关心标准库等等的具体实现
        * 具体实现 how
        * 是什么东西（接口） what
    * 编程时不要关心多余东西的实现
* 抽象 从底层逐渐向顶层抽象（本课程采用这种方式）
    * 从基本的门逐渐封装为CPU等复杂芯片
    * 将其放入计算机为软件层服务
    * 将已经封装的抽象到下一个级别

### 本课程要构建的硬件 

* 计算机 CPU RAM ROM 等
* 连接鼠标键盘等
* 编写程序，运行

* 硬件部分专注于逻辑门，而不是芯片的制造等（这不是计算机领域）
    * 组合逻辑
    * CPU, 寄存器等
    * 最终组成计算机
* 使用硬件模拟器

* 硬件部分的课程内容
    * 建造一些基本的逻辑门
    * 建造一个算术逻辑单元 ALU
    * 建造存储系统 寄存器 RAM ROM
    * 用机器语言写一些程序，以了解这台计算机要做什么
    * 组成计算机！
    * 开发适合编写的机器语言的汇编器

### 本课程要构建的软件

* 构建非常低级的汇编语言以编写程序
* 了解软件的层次结构
* 构建一种高级语言，并构建编译器
* 构建标准库

## 1 逻辑门

### 布尔逻辑

| 0 | 1 |
| - | - |
| F | T |
| N | Y |

#### AND OR NOT

#### 布尔逻辑的基本组合计算

NOT(0 OR (1 AND 1))

#### 布尔逻辑表达式

f(x, y, z)=(x AND y) OR (NOT(x) AND z) 

了解此类函数的一种方式是列举所有x, y, z写下函数的值

![](img/truthtable.png)

另一种方式是通过公式化简

**交换定律**

* (x AND y)=(y AND x)
* (x OR y)=(y OR x) 

**结合律**

* (x AND (y AND z))=((x AND y) AND z)
* (x OR (y OR z))=,,

**分配律**

* (x AND (y OR z))=(x AND y) OR (x AND z)
* ..

**摩根定律**

* NOT(x OR y)=NOT(x) AND NOT(y)
* ..

### 从真值表构建布尔函数

* 逐行只关注表中输出取1的值
* 列写表达式,使得该表达式仅在本行的各个输入状态时取得1
* OR连接各行的表达式
* 化简

**任何真值表都能转化为AND, OR, NOT的组合**

*OR和AND可以放弃一个，因为他们可以用另外两种表示，但是不能放弃OR或者放弃两个*

### 与非门 NAND

x NAND y = NOT(x AND y)

*与非们可以用自己完成逻辑运算，因为无论AND, OR, NOT都可以由其表示*

你将要使用NAND构建你的计算机！

### 硬件实现布尔函数

**什么是逻辑门？**

逻辑门是一种独立的芯片，有着自己独立的功能

**复合逻辑门**

是由基本逻辑门和其他复合逻辑门组成的复杂一点的逻辑门

#### 基本逻辑门 

NAND, AND, OR, NOT

*用户如何使用门，只需要关注接口（输入与输出），但是如果希望了解门如何实现的，需要打开黑匣子，了解其内部构成*

#### 电路实现

*AND电路的实现*
![](img/ele.png)

### HDL 电路模拟语言 以异或门为例

在HDL构建的逻辑门可以实际对其模拟，测试

* 首先需要真值表（也被称为接口）
* 构建合适原理图

![](img/fb69ecb2.png)

#### 编写HDL文件

```HDL
/** Xor gate: out = (a AND NOT(b)) OR (NOT(a) AND b) */

CHIP Xor {
    // 接口部分
    IN a, b;
    OUT out;

    PARTS:
    // 实现部分
    // 逐一描述原理图
    // 每一个中间输出起合适的名字
    Not (in=a, out=nota);
    Not (in=b, out=notb);
    And (a=a, b=notb, out=aAndNotb);
    And (a=nota, b=b, out=NotaAndb);  
    Or (a=aAndNotb, b=NotaAndb, out=out);
}
```

HDL是一种声明式的语言，不参与实际程序的运行，是门的静态表述

与先后顺序无关，不过习惯上从I到O

### 硬件模拟

* 测试模拟器, 根据更改不同的输入来获取输出，同时可以看到中间输出
* 编写测试语言文件（可以整理一组预先确定的可复制文件）
* 与脚本文件进行比较

#### 测试脚本

```tst
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/1/Xor.tst

output-list a b out;

set a 0,
set b 0,
eval,
output;

set a 0,
set b 1,
eval,
output;

set a 1,
set b 0,
eval,
output;

set a 1,
set b 1,
eval,
output;
```

### 多位输入输出 bus 

*在操作硬件的时候，有时候会操作一堆具有相同地位的输入，将一堆作为一个实体进行整体操作很方便*

这种整体称为**bus**

#### HDL 关于bus

```HDL
CHIP ADD16{
    IN a[16], b[16];
    OUT out[16];

    PARTS:
        ...
}
```

当16位加法器被实现之后，如果我们想实现一个16位三数加法器，逻辑上显然可以使用两次两位加法器，在HDL中的做法：

![](img/ed8b63c4.png)

即某一芯片的接口规定了bus输入输出，那么在使用的时候可以直接输入输出**整个bus**

如果在不是输入接口不是bus的芯片上输入bus数据的某一位，可以用bus数据[..]

![](img/b4ebafc0.png)

而芯片的bus接口也可以分段输入输出

![](img/7d0bcb08.png)

芯片的输入可以为常量 true 或 false

芯片的输出也不必全部需要，允许只输出一部分

### Project 1 简介

从Nand 开始，建造如下逻辑门

* Not And Or Xor Mux DMux 
* Not16 And16 Or16 Mux16 
* Or8Way Mux4Way16 Mux8Way16 DMux4Way DMux8Way

最常见和广泛，在计算机中广泛运用

#### 一些逻辑门的介绍

* Mux 多路复用器
    * 输入 a b sel
    * 输出 out
    * 当 sel 输入 0 out = a
    * 当 sel 输入 1 out = b
* DMux 解复用器
    * 输入 in sel 
    * 输出 a b
    * 当 sel 输入 0 则 a 输出 in 的值，而 b 保持 0
    * 当 sel 输入 1 则 b 输出 in 的值，而 a 保持 0
* And16
    * 输入 a[16] b[16]
    * 输出 out[16]
    * 16位中的每一位进行AND
* Mux4Way16
    * 输入 a[16] b[16] c[16] d[16] sel[2]
    * 输出 out[16]
    * 根据 sel的四种可能性来选择 a b c d

允许使用之前编写过的逻辑门

允许建立其余的芯片来辅助，但是没有必要

编写逻辑门，运行脚本，diff差异！

### 基本逻辑门 Q&A

**是否可以从非NAND的逻辑门建立计算机？**

是的,比如还有一种逻辑门NOR，它也可以构成任意逻辑门，或者从AND,OR,NOT自然地构建,用NAND门构建很常见，它也很便宜。

**如何去建造一个NAND门？**

这是物理学或者电子学的问题（模电），可以用电阻，晶体管等构建

**我们使用的HDL和硬件工程师使用的HDL相比？**

我们使用的HDL很好，是老师构建的，而工程师使用的更复杂一些，有一些C语言的形式，有循环等内容（16路不用CV16次了）,具有模拟功能，也能模拟时间和时钟，不过掌握时间长一些。

**我们目前建造的芯片很简单，如何制造包含数百个零件和连接的芯片？**

没有通用的方法去设计，需要一些聪明才智，我们已经学到一些技巧比如化简，也有一些编译器来制定功能，它们有一些算法来优化（但不是完美的，因为某种理论）

## 2 布尔运算和ALU

### 二进制表示整数

| Binary | Decimal |
| - | - |
| 0 | 0 |
| 1 | 1 |
| 10 | 2 |
| 11 | 3 |
| 100 | 4 |
| 101 | 5 |

如8位二进制在计算机中表示2^8=256个数（通常保留一位标识正负但也是128+128=256个数）

十进制转化二进制的一种方式：

每次找到最大的2^n, 余下的用2^(n-1)尝试

如 87 = 64 + 0 * 32 + 16 + 0 * 8 + 4 + 2 + 1 

-> 1 0 1 0 1 1 1

99 = 64 + 32 + 0 * 16 + 0 * 8 + 0 * 4 + 2 + 1 -> 1100011

### 二进制加法

![](img/d02a0312.png)

和十进制加法类似地，当每一位（包括前一位的进位）加和大于等于2之后，减去2,并进位1

当最高位发生进位时（假设输出位数与输入相同），会出现**溢出**，在计算机中会被丢弃

**构建用于加法的硬件**

* 半加器 两位相加
* 全加器 三位相加
* 加法器 两个数加和

#### 半加器

| a | b | sum | carry |
| - | - | - | - |
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 1 |

#### 全加器

| a | b | c | sum | carry | 
| - | - | - | - | - |
| 0 | 0 | 0 | 0 | 0 | 
| 0 | 0 | 1 | 1 | 0 |
| 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | 1 |
| 1 | 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 |

#### 加法器

按照真实的进位步骤进行

### 二进制负数

一种方式是把最高位（以四位二进制为例）作为符号位，当最高位为1,则为负数

| 二进制 | 数字 |
| - | - |
| 1100 | -4 |
| 1110 | -6 |
| 1000 | -0 | 

存在 -0 的问题，会带来一些问题，不好

改用的方案：

仍然使得最高位为0的为整数（0），为1的是负数，但是使用补码：使用2^n - x

以四bit为例，表示-1则使用16 - 1 = 15 > 1111

这样下来非负数可以表示0000-0111共8个数，负数可以表示1111-1000（-1～-8）共8个数

这种方案还可以直接地得到负数的加法，以及减法（基于某种数学原理）

比如 7 - 5 直接使用 7 - （-5）计算即可得到正确结果 2

因此构建减法器，实际上难点为如何计算出负数的二进制

而我们知道补码法确定-x实际上为2^n - x

即为1 + 2 ^ n - 1 - x 而 2 ^ n - 1 为 111111... - x 翻转 x的各个位即可

所以说**想得到一个负数的二进制，就把它的绝对值二进制的所有位翻转再加1**

最后加一的方式也很特别，可以在这个翻转数从低到高再翻转，直到碰到0,将这个0翻转后结束

### 算术逻辑单元 ALU

*冯诺依曼在论文中构建的体系结构*

![](img/7a22cf33.png)

可见其体系结构中CPU是计算机结构中的重要组成，而ALU是CPU中的重要结构

ALU有两个输入input1, input2

有一个函数控制（可能是逻辑函数或算术函数）

输出为f(input1, input2)

通常的计算有 整数加法、整数乘法、整数除法 逻辑运算如按位与、按位或等

**要在ALU中构建多少功能？**

这是一个权衡问题，如果不再硬件中实现某些东西，可以随时用软件对其扩展


#### 一个示例ALU The Hack ALU

* 输入 x[16] y[16]
* 输出 out[16]
* 功能选择 zx nx zy ny f no 他们的组合可以产生如下功能

![](img/2aebc5d5.png)

* 此外还有两个控制输出 zr, ng

### The Hack ALU 的控制

![](img/2561cca6.png)

#### zx ZEROx 

当 zx = 1 将输入的 x 设置为 0 

#### nx NOTx 

当 nx = 1 将输入的 x 取反

控制**按序而非同时发生**，比如 zx 和 nx 都为 1,先 zx 把输入置零，再取反置一

#### zy ZEROy ny NOTy

#### f

如果 f = 1 则计算 x + y, 否则计算 x AND y

请注意，**目前这五步包括尚未发生的下一步，仍是按序进行**

#### no NOT

如果 no = 1 否定输出结果

### The Hack ALU 输出的控制位

用来表示ALU的主要输出

如果 out = 0 则 zr 会 置1（zero）

如果 out < 0 则 ng 会 置1（negative）

### Project 2 概述

可以使用 Project 1 的全部实现

构建如下芯片

* HalfAdder
* FullAdder
* Add16
* Inc16
* ALU

#### HalfAdder

* 输入 a, b
* 输出 sum, carry
* 将两位相加，并输出两位的总和以及进位

#### FullAdder

* 输入 a, b, c
* 输出 sum, carry
* 将三位相加，并输出三位的总和以及进位

#### Add16

* 输入 a[16], b[16]
* 输出 out[16]
* 进行16位加法运算

#### Inc16

* 输入 In[16]
* 输出 out[16]
* 给传入值加1

#### 最有趣的部分 ALU

如上所述
不到20行代码即可实现

### 组合逻辑以及ALU 单元 Q&A

**我们在这门课已经制造了约20个芯片，它们是标准的吗？**

是的，半加器，全加器，加法器，多路复用器，异或门等等，这些都是在其他计算机中通用的器件。不过我们所建造的ALU不完全标准，它更简单（简单性也是本课程所着重的）

**为什么我们构建的ALU没有更多的如乘法和除法运算?**

如果在HDL代码中编写是可以实现的，但是有一些优雅和好的算法可以做到这点。我们在构建计算机系统时，系统提供的整体功能包括硬件和运行于其上的操作系统。而设计师可以自行决定每层的功能多少。在我们的设计中我们简化了ALU，乘除法运算将放在软件部分。

在本课程的第二部分，我们将设计一个操作系统，其包含了几个库，如数学库，其中就会包含如乘法和除法的运算。对于应用层程序员来说，不会注意到运算是由操作系统还是硬件完成的。这个问题的取舍点在于通常在硬件层的设计运行速度会快很多，但是设计成本很高（更复杂的硬件）

**这个ALU的效率？**

我们在本课程中设计的所有部分都是高效的，但是有一个组件可以进行优化：

**加法器的优化**

在我们之前的设计中，加法器由若干全加器组成，每个全加器从上一个全加器运算得到的进位中获取输入，这就导致了只有上一个全加器结束工作后，才开始工作。

假设每个全加器中有3-4个门组成，那么一个16bit的加法器耗时约为 4 * 16 * n = 64n 其中n为信号在每个门中处理的平均时间

**优化的思想是独立计算进位**

**为什么建议在project 2中使用内置芯片，而不是我们之前自己构建的芯片？**

欢迎使用自己的芯片，不过可能会面临局部失败的问题，避免之前构建的芯片有一些bug（可能侥幸通过了测试点），这也是一种单元测试，与系统的其余部分进行分离，避免干扰。在真实的项目中，当构建了某一底层功能之后，可以不必使用它，而是模拟它的接口和API来分离项目。（PS 内置的芯片由于实现规定了输入输出运行很快，而我们的芯片模拟器在执行时会从头开始，很慢）

## 3 内存

### 顺序逻辑

*在前两周中，我们忽略了时间的问题，假设一切立即发生，假设了芯片的功能是随输入立即输出*

但是面对真实的情况，我们需要引入时间，这需要解决两个问题：

* 使用相同的硬件随着时间连续地计算事物，比如说连续地加一系列数
* 记住过去发生的事，记住中间结果，正在计算的位置

物理上的时间是连续的，而我们要把这种连续的时间转化成容易处理的离散时间，这需要利用“时钟”——一种固定震荡的装置

![](img/0121c049.png)

在时钟的指示下，连续的物理时间被分割成等长的部分 t = 1, 2, 3...

这个等长的时间就是计算机中最小的时间单位，在这段时间当中，所有东西不会变化，只有在时钟交替时，输入输出才会改变

![](img/1e99c477.png)

如图所示的非门，在时钟到来时，输入发生变化，而输出也随之瞬时变化

但是我们**不得不考虑延时的问题**

真实的模拟过程有一定延迟，但我们在计算机中不会考虑，当我们的时钟间隔足够时，我们就可以忽略，这不会对输入输出的变换产生影响

![](img/25fe9402.png)

因此时钟选择的关键就是确保硬件在下一个时钟到来之前稳定下来达到终态

* 组合逻辑 out[t] = function(in[i]) 输入随输出瞬时变化
* 顺序逻辑 out[t] = function(in[t-1]) 输入后，预留出一个时钟的处理和延迟时间，在下一个时钟到来时输出

在顺序逻辑中，特别地，如果我们把上一个时钟的输入a在下一个时钟的输出f(a)继续投入到输入

![](img/0cf1ae51.png)

我们在时间上即不断地改变状态，无需记忆最初的a，只是在前一步的基础上计算

### 记忆状态 D 触发器

我们现在可以做到在某一时钟瞬时进行计算，但是有一件事情：如何在计算完毕之后，保留输出直到下一个时钟到来呢？我们需要某种记忆的器件，它能够进行0、1之间的切换，并且在下一次信号到来之前记住当前的数字

这种器件称之为 **D 触发器**

* 输入 in
* 输出 out
* out[t] = in[t - 1]
* 记录上一时钟的值，并在下一时钟输出

![](img/d5ac2b50.png)

小三角号表示这是一个顺序芯片，与之前我们的组合芯片不同，输出在下一个时钟

**关于D触发器的实现**

类似于NAnd，本课程把D触发器作为基石，实际上可以使用NAnd利用某种循环，进行建造。


因此在计算机中，我们通过D触发器来记忆信息，通过组合逻辑门在瞬时处理信息：

* 经过D触发器保存的信号在时钟到来时输出，并经过组合逻辑处理后，连同新增的输入，再次送到D触发器保存

![](img/a8e8ee0f.png)

#### 1-bit 寄存器

* 输入 in
* 输出 out
* 加载位 load
* 当load = 1, 会记住此时的in,即使得 out = in
* 当load = 0, out 保持
* 由于其时序特性，相应的out会滞后in和load一个时钟显现

### 存储单元

存储单元分为**主内存**，**辅助存储器**

* 主内存也有不同的分类
    * RAM 随机存储器，用于运行程序所依据的数据和指令
    * ...
* 辅助存储器的分类
    * 硬盘等
* 存储单元也有易失和非易失的区分（根据断电是否会丢失数据） 

我们关注于存储单元的逻辑，并重点关注RAM

#### 16-bit 寄存器

可以通过我们上节课建造的1-bit寄存器重复放置，构建16-bit寄存器

* 计算机中寄存器的长度我们成为w(word width)，有些是32位和64位
* 寄存器状态 是存储在寄存器中的值（目前由寄存器的内部电路所表示的值）

**如何读出寄存器状态？**

直接获取寄存器的输出即可

**如何写入新值到寄存器？**

如果要设置寄存器的值为v，那么设置输入为v，同时将加载位置1,那么寄存器的状态就变成了v，同时当下一时钟到来时，输出也变成了v

*值得注意的是寄存器状态不需要时钟结束后才变化*

#### RAM

![](img/da5d8681.png)

我们把它视为一系列可寻址寄存器，即含有n个寄存器的RAM有0 ~ n - 1个地址

无论RAM中有多少寄存器，在一个时间点，都只会选择一个寄存器生效

* 地址的长度k = log2(n)
* 字w（每一个寄存器的位数）在我们的计算机中等于16

**如何读取RAM某个寄存器的值？**

设置地址为想要的寄存器地址，在下个时钟来临时，读取输出out

**如何设置RAM某个寄存器的值？**

设置地址为目标寄存器地址，设置输入为某值，同时加载位置一，寄存器的状态就会被改变，同时下个时钟到来时，RAM的输出也会改变为新值（如果地址仍是这个寄存器）

我们需要构建 RAM8 RAM64 RAM512 RAM4k RAM16k 这些数字表示w

**为什么叫RAM？**

RAM表示随机存储器，意味着有着能力只要根据地址就能立即选出任何寄存器

### 计数器

*一个会根据程序做蛋糕的机器人，我们写出一个很具体的50个指令，在这些指令旁边有一个计数器，它会告诉机器人它下一步执行的指令编号，当机器人执行若干指令时，当到一定阶段的末尾，我们可以让计数加1，机器人会根据计数器，接着执行下一个指令*

*我们也需要让计数器的数字可以跳转到特定数，完成指令的循环等操作*

因此我们需要能完成三种功能的计数器，**清零**（以便机器人从头开始执行），**自增**，**跳转**

![](img/63718e24.png)

* 输入 in[16]
* 输出 out[16]
* 控制位 load inc reset
* 如果reset置1,那么时钟到来时out会清零
* 如果load置1，同时给了in,那么在时钟到来时，out会输出之前in的值
* 如果inc置1,那么时钟到来时out会在上次的基础上自增1
* 如果所有位都置0,那么时钟到来时out不变

### Project3 概述

基于Project1和2构建的所有芯片，以及D触发器（Data)

![](img/ea63285b.png)

### 存储系统单元 Q&A

**在本单元，我们使用了触发器但是没有真正构建它，怎样真正构建一个触发器？**

在常见的计算机课程中，通常教学生们从与非门构建触发器，但在我们的课程中，更强调组合逻辑和时序逻辑间的区别，以下是构建的方式：

![](img/62dbddb6.png)

把两个与非门连接在一起，每一个的输出连接进另一个的输入（通常这是不被允许的，不应该在组合门中出现循环）

1. 最开始时两个单独的输入置1，这时我们并不知道输出也就是另外两个输入的值
2. 当某一个单独的引脚置0，由于是与非门，其输出确定为1，同时这个1进入另一个与非门的输入，把其输出变为了0，这个输出又进入前者的输入，形成稳态
3. 当我们再次改变置0的那个引脚，把它置1,由于其另一个引脚是0,不会发生变化
4. 但当我们改变另外一个单独的引脚为0时，其输出变成了1,同时进入另一个与非门的输入，因为我们之前改变了这个与非门的另一个引脚为1,所以其输出0,0进入前者的输入，形成稳态（和2一样）
5. 这种结构记住了最后一个置0的引脚（把其输出最终置1），输入的瞬时变化改变另未来的输出

**NAND门是构建存储系统的唯一基本技术吗？**

不是的，在一些系统中，根据基础固体物理的一些性质来构建存储系统，是物理或者电子工程的范畴。

**我们构建的RAM是计算机唯一使用的存储设备吗？**

不是的，但是RAM是最重要的，它是一个易失的，断电丢失数据。

计算机还常用一种成为ROM只读存储器的设备，它是非易失性的，会维持现有内容很长时间。

也因此ROM是程序存放的地方，在启动过程（boot up）时程序预先在ROM中运行，其会初始化所有内容（在低级代码中），并会从磁盘克隆操作系统的启动代码。

另一种技术叫闪存，它结合了RAM和ROM的优点，可读可写，不依赖电源

还有一种方式叫缓存

**什么是缓存，我们为什么需要它？**

存储是计算机中很昂贵的内容，记忆越快，越多，就会越贵

缓存就是小而快的记忆，除此之外，还有一些缓慢，但是更大的存储，这种层次结构更有效

## 4 机器语言

### 机器语言概述

之前我们构造了ALU和内存，下周我们将其组装为计算机，本周我们以用户的视角来看待我们的计算机要做什么

计算机可以做很多事，不同于其它机器。我们要用同一硬件运行不同的软件

这也是通用图灵机的概念，而冯诺依曼完整地架构了这种机器：**通过程序软件放入硬件,不同的程序会创建不同的操作，完成不同的功能**

![](img/7f62fc19.png)

让我们回到计算机系统原理图思考如何做到这一点
