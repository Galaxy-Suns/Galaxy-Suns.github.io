# 传输层

为应用程序间数据通信提供服务

* `UDP` 简单不可靠的字节流
* `TCP` 可靠的双向字节流

## tcp服务模型

当应用程序使用TCP时，会将字节传给TCP 并希望由TCP传到另一端

1. TCP将字节放入TCP段(TCP中的数据包)中 并开始处理
2. TCP将段交给IP层 IP层将其封装到IP数据报中
3. IP数据报又被传递给链路层 构建链路帧 添加链路地址 发送到网络

![](img/9ff4d540.png)

在两个应用使用TCP时，会在各自的TCP之间建立一个双向的通信通道：

1. 主动发起方的TCP先建立到对方TCP的通道
2. 接收方TCP又建立通道到主动方TCP
3. 形成的双向通信叫**连接**
    * 在连接的两端 TCP维护一个**状态机**跟踪连接的状态

![](img/d3e157ee.png)

### 三次握手

连接通过三次握手建立

* A向B发送消息 表示A的TCP想要建立连接连接到B的TCP 
  * `SYN` 同步 因为A还发送正向字节流的起始序号
* B回复 `SYN+ACK` 同步、确认 B确认A的请求并同意建立连接 同步表示B还发送反向字节流的起始序号
* A回复`ACK` 接受反向通信的请求

![](img/2d802b2d.png)

### 字节流

主机间相互发送数据 如同连续的字节流 

![](img/a04b0c0d.png)

来自A的字节流被B接收 A和B的TCP层协同工作 确保字节流按正确顺序传递到B

流被封装入TCP段 传递给下方 当到达B的TCP段 流被从TCP段提取出

TCP段可以小到一个字节 但是为了效率 可以填满到最大IP数据报的大小

### 连接的拆除

当完成传输后 双方关闭连接 并清楚与状态机有关状态

1. A发送 `FIN` 完成
2. B `ACK` 确认A没有数据发送 停止寻找来自A的新数据
    * 此时关闭了A到B的通道 但是B仍然可以有一些新数据发送给A 因此还会发送一些`Data`
3. 没有要发的数据后 B发送`FIN` 完成
4. A `ACK` 确认 停止寻找来自B的新数据

![](img/ee2149e2.png)

此时连接完全关闭 状态可以安全移除

### 连接可靠性

TCP有四种机制

* 当TCP层收到信息 会给发送方一个**确认信息** 告知数据正确到达
* 用**校验和**检测损坏的数据
  * TCP首部包含校验和 涵盖首部和段中的数据
* **序号**检测丢失数据 和 顺序
  * 每个段首部含有 该段第一个字节的序号 
  * 如双方约定从1000开始计数 那么第一个段的序号是1000 而段中500字节 则第二个段序号 1500
* **流量控制**防止接收方超载
  * 如果A发送比B接收的速度快很多 那么就会出现超载的情况
  * TCP使用流量控制 阻止这种情况 
  * 接收方 不断告诉 发送方是否可以继续发送 具体而言 是告诉发送方 缓冲区还有多少空间可以接收新数据

此外 TCP对网络进行堵塞控制 其试图将网络容量平均分配给使用网络的所有TCP连接

## tcp段格式

* 目标端口 告诉本地TCP层 将字节传递给另一端哪个应用程序 
* 源端口 告诉另一端TCP层 使用我的哪个端口 发送数据回来
* 段的序号
* 确认序号 告诉另一端接下来期待哪个字节 *成功接收到了此前的所有字节*
* 16位校验和 在整个段上计算
* 报头长度 间接告诉我们有多少可选字段 通常没有
* 可选字段
* 一些传递信息的标志
  * `ACK` 表示 **确认序列号字段** 是有效的
  * `SYN` 表示 我们正在进行同步 这个段用于握手
  * `FIN` 表示 连接单方向关闭
  * `PSH` 告诉另一方 到达后立即向应用传递数据 而非等待更多数据

![](img/19240b8d.png)

## tcp连接的唯一性

通过TCP和IP头部的五个信息实现唯一性

* IP源和目的 唯一标识端点
* IP头的协议ID 为 TCP 表示传输层用的协议
* TCP 源端口和目的端口 

而发送方源端口号通常唯一 但是如果新增大量连接 也可能出现使用一个源端口号的情况 此时 随机选择的初始端口降低混淆的可能

1. 从A到B发送的段 序列号为偏移初始序列号后的第一个字节序列号
2. 从B到A返回的段中 确认序列号 告诉A B接下来期待哪个偏移初始序列号后的字节

## 端口号的工作原理

假设现在B服务器运行两个服务 邮件服务器 和 web服务器

1. 当A上的浏览器（web客户端）想从B上的web服务器请求页面 则将请求数据发送给TCP
2. 假设双方的TCP已经完成握手 建立连接 那么现在只需要发送数据
3. A的TCP创建段 并写入目标端口 80 而来源端口 写入本地生成的 如`123456` 
4. 封装为IP数据报
5. IP数据报到达B后 解出TCP段 送往上层TCP层
6. TCP看到目标端口80 则将数据发送给web服务器 

![](img/08707296.png)

## udp 服务模型

另一种传输层协议 为不需要TCP保证交付服务的应用使用 这些应用或许不需要重传 又或许自行处理重传

udp数据报 只用来标识在另一端接收数据的应用

其结构是

* 来源端口 数据来自哪个应用
* 目标端口 
* 整个UDP数据报的长度
* *可选的校验和* 发送方不包含时 则填充0
  * 计算也包含一部分IPv4的内容 *违反分层原则 的原因是 允许udp 检测到 被传输到错误目的地的报文*

![](img/e308710f.png)

其端口工作原理和TCP相同

![](img/ab88d6a9.png)

多路分解机制 根据到达端口号的不同 将到达报文划分 送到不同进程

* 无连接
* 任意顺序 应用程序根据需要可以自行处理
* 不可靠的交付 无确认 无通知 应用程序可能会自己选择实现重传机制

应用如DNS 发送一个包含主机名的DNS请求 DNS服务器响应一个IP 这个请求就使用UDP

UDP很快

* 对时间有要求
* 对TCP中实现的一些机制有自己的特殊要求

## ICMP服务模型

ICMP 互联网控制报文协议 用来报告错误并诊断网络层的问题

使得网络层正确工作的三个部件

* IP协议 逐跳地端到端转发分组
* 路由表
* ICMP协议 帮助在主机和路由器之间传递有关网络层的信息

ICMP在网络层之上 严格来说是传输层协议

当目标或者路由想向源报告错误时，将信息包裹在ICMP中 交给IP层发送

![](img/a648ba37.png)

### 例子 目标网络不可达

从A的浏览器到B的web服务端 A发送一个http请求

![](img/fa86ac64.png)

然而这个路由表没有存储相关目标的信息 它不知道如何转发到B 

这样路由表会发送回一条信息 内容包括目的地网络不可达

* 不可靠 不会重新发送 只是发送一个摘要 取来源IP数据报的一些信息 放到到ICMP的报文 然后整个ICMP包放到新的IP数据报

ICMP有很多信息类型

![](img/b776e731.png)

* 网络不可达 路由器不知道如何转发
* 主机不可达 到达最后一个路由器 但是路由器不知道主机在哪
* 端口不可达 主机不知道端口如何处理 无法识别目标端口

### ping

用来测试另一个主机是否存活 以及 我们是否与其连接

ping程序直接调用ICMP 发送ICMP echo 请求 type 8 code 0 

封装入IP报 发送到网络

![](img/1bf8fad4.png)

如果请求能到达B B做出 ICMP echo 响应 type 0 code 0 

![](img/cc937e57.png)

### traceroute

告诉我们数据包在网络中经过的路径以及访问的路由器 到每个路由器的往返时间

通过发送UDP消息来做到这一点

1. A发送UDP消息 封装为IP数据包 其中TTL字段设置为1
2. 当数据包到达第一个路由 TTL减1 变为0 被丢弃 但是丢弃时 会向A发送一个ICMP错误报告消息 type 11 TTL超时 
    * 封装入原IP数据报的一些信息 
3. 消息送回A时，它从消息得知 发生TTL超时 并从ICMP的载荷部分得知 是之前自己发送的原始消息 TTL=1的那一条
    * 并从IP头找到路由器的地址
    * 进行标记
4. 发送TTL设置2的消息 ...以此类推

![](img/b9ed6607.png)

当到达B时，A选择的是一个不合法的端口 这样B也会返回一个ICMP



