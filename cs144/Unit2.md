# 传输层

为应用程序间数据通信提供服务

* `UDP` 简单不可靠的字节流
* `TCP` 可靠的双向字节流

## tcp服务模型

当应用程序使用TCP时，会将字节传给TCP 并希望由TCP传到另一端

1. TCP将字节放入TCP段(TCP中的数据包)中 并开始处理
2. TCP将段交给IP层 IP层将其封装到IP数据报中
3. IP数据报又被传递给链路层 构建链路帧 添加链路地址 发送到网络

![](img/9ff4d540.png)

在两个应用使用TCP时，会在各自的TCP之间建立一个双向的通信通道：

1. 主动发起方的TCP先建立到对方TCP的通道
2. 接收方TCP又建立通道到主动方TCP
3. 形成的双向通信叫**连接**
    * 在连接的两端 TCP维护一个**状态机**跟踪连接的状态

![](img/d3e157ee.png)

### 三次握手

连接通过三次握手建立

* A向B发送消息 表示A的TCP想要建立连接连接到B的TCP 
  * `SYN` 同步 因为A还发送正向字节流的起始序号
* B回复 `SYN+ACK` 同步、确认 B确认A的请求并同意建立连接 同步表示B还发送反向字节流的起始序号
* A回复`ACK` 接受反向通信的请求

![](img/2d802b2d.png)

### 字节流

主机间相互发送数据 如同连续的字节流 

![](img/a04b0c0d.png)

来自A的字节流被B接收 A和B的TCP层协同工作 确保字节流按正确顺序传递到B

流被封装入TCP段 传递给下方 当到达B的TCP段 流被从TCP段提取出

TCP段可以小到一个字节 但是为了效率 可以填满到最大IP数据报的大小

### 连接的拆除

当完成传输后 双方关闭连接 并清楚与状态机有关状态

1. A发送 `FIN` 完成
2. B `ACK` 确认A没有数据发送 停止寻找来自A的新数据
    * 此时关闭了A到B的通道 但是B仍然可以有一些新数据发送给A 因此还会发送一些`Data`
3. 没有要发的数据后 B发送`FIN` 完成
4. A `ACK` 确认 停止寻找来自B的新数据

![](img/ee2149e2.png)

此时连接完全关闭 状态可以安全移除

### 连接可靠性

TCP有四种机制

* 当TCP层收到信息 会给发送方一个**确认信息** 告知数据正确到达
* 用**校验和**检测损坏的数据
  * TCP首部包含校验和 涵盖首部和段中的数据
* **序号**检测丢失数据 和 顺序
  * 每个段首部含有 该段第一个字节的序号 
  * 如双方约定从1000开始计数 那么第一个段的序号是1000 而段中500字节 则第二个段序号 1500
* **流量控制**防止接收方超载
  * 如果A发送比B接收的速度快很多 那么就会出现超载的情况
  * TCP使用流量控制 阻止这种情况 
  * 接收方 不断告诉 发送方是否可以继续发送 具体而言 是告诉发送方 缓冲区还有多少空间可以接收新数据

此外 TCP对网络进行堵塞控制 其试图将网络容量平均分配给使用网络的所有TCP连接

## tcp段格式

* 目标端口 告诉本地TCP层 将字节传递给另一端哪个应用程序 
* 源端口 告诉另一端TCP层 使用我的哪个端口 发送数据回来
* 段的序号
* 确认序号 告诉另一端接下来期待哪个字节 *成功接收到了此前的所有字节*
* 16位校验和 在整个段上计算
* 报头长度 间接告诉我们有多少可选字段 通常没有
* 可选字段
* 一些传递信息的标志
  * `ACK` 表示 **确认序列号字段** 是有效的
  * `SYN` 表示 我们正在进行同步 这个段用于握手
  * `FIN` 表示 连接单方向关闭
  * `PSH` 告诉另一方 到达后立即向应用传递数据 而非等待更多数据

![](img/19240b8d.png)

## tcp连接的唯一性

通过TCP和IP头部的五个信息实现唯一性

* IP源和目的 唯一标识端点
* IP头的协议ID 为 TCP 表示传输层用的协议
* TCP 源端口和目的端口 

而
