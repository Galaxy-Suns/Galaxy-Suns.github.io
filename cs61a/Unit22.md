# 解释器_编程语言
 
解释器是一个接受以编程语言编写的代码作为输入的程序，然后执行该代码以创建程序描述的行为

解释器的工作过程是树递归

解释器是模块化和可扩展的

解释器程序的一部分将描述解释的一般工作原理，另一部分将封装语言的各个部分实际执行的所有细节

## 编程语言

计算机通常执行用许多不同编程语言编写的程序

* **机器语言** 语句由硬件本身解释 *计算机的中央处理单元，可以执行一组固定的指令，并且具有有限的寄存器可以直接使用，一些访问远距离的更多内存的方法* 机器语言的拓展需要更改计算机的电路，因此不常发生
    * 这种语言难以编写，基于操作特定的硬件内存地址，很少有抽象机制，一般没有办法命名，函数或操作
* **高级语言** 具有由另一个程序进行解释的语句和表达式(或者被编译为另一种语言), 解释涉及到阅读程序并执行其行为，而编译则将其翻译为另一种语言如机器语言，以便后续执行
    * 很多现代语言在这两者之间混合 实时编译部分，以便像交互式解释那样执行
    * 提供抽象的手段 命名 函数 类...
    * 我们的计算机中没有专为`Scheme`或者`python`而设计的硬件部件, 而是最终转化为机器语言执行，解释器或编译器是两者之间的桥梁
    * 高级语言往往建立在其他高级语言之上 如 机器语言可能用来实现`C语言`的编译器，而`C语言`可以用来构建`Python`解释器

高级语言也提供了抽象的手段，以将编写解释器时，将某些系统细节忽略掉，以适配不同的机器语言

`Python`在运行前被编译为`Python` 3 字节码

![](img/f8f5819d.png)

之后由运行这种较低级字节码的解释器 也会抽象掉一些细节

编程语言具有

* **语法** 即语言中所有合法语句和表达式的描述 `syntax`
* **语义** 这些语句和表达式的执行或评估规则 `semantics`

一个新的编程语言需要有一个形式规范，将其写成文档，描述语言的精确语法和语义

或者构建一个其解释器或编译器的实现，作为语法和语义的参考描述

* Scheme 起始于规范 而后才有解释器的实现
* Python 起始于实现 而后开发了对其工作原理的正式描述

## 解析 读取Scheme代码列表 返回python中的表达式

要将文本解释为编程语言，首先需要将该文本解析成一些结构，以便对其轻松进行解释

`Scheme`代码基本上是树形结构的 `(表达式(表达式(表达式(..))))`

解析**把这些文本表达式转化为表达式树**，以便根据语言规则来评估代码

`Scheme`程序看起来像是一个带有括号、符号、数字等的`scheme`列表，我们首先编写一个程序，读取`scheme`的“列表”并将其转换为具有正确结构的列表显示 *具有first 和 rest两部分的列表*

我们应在将列表构建为`python`中的对象

![](img/869a3003.png)

解析的任务就是将这种字符串，转化为`python`可以读懂、处理的表达式

### scheme_reader 

接受文本输入，返回一个表达式

![](img/7225714d.png)

* `str`为其在`scheme`的表示
* `repr`为其在python中的表示

![](img/71ca7b70.png)

`scheme_reader.py`中定义了`Pair`和`nil`类

并且其中还有`scheme_reader`函数，其行为如下 *部分实现*

获取`token`并返回`python`的表达式

```py
    >>> scheme_read(Buffer(tokenize_lines(['nil'])))
    nil
    >>> scheme_read(Buffer(tokenize_lines(['1'])))
    1
    >>> scheme_read(Buffer(tokenize_lines(['true'])))
    True
    >>> scheme_read(Buffer(tokenize_lines(['(+ 1 2)'])))
    Pair('+', Pair(1, Pair(2, nil)))
```

![](img/8c4d4379.png)

### 解析的结构

`Parse`由两部分组成

* 词法分析 获取标记序列 tokens `lexical analysis`
    * 检查格式错误的token，确定token类型，逐行处理
    * 项目中不需实现
* 语法分析 处理tokens并返回python表达式 

![](img/8cc14e35.png)

![](img/08d9f941.png)

#### 语法分析 Syntactic analysis

输入token，通过平衡括号递归地将其转化为树

识别表达式的分层结构（嵌套）

基本的情况是符号和数字

递归地读取合并子表达式 

找到正确的括号才会返回

通过调用`scheme_read`来实现

## scheme语法计算器

输入解析好的scheme表达式的各个部分 以返回正确结果

![](img/fd844519.png)

仅包含基本表达式(数字)和调用表达式(以加减乘除开头) 

可以嵌套

* 数字将被评估为自身
* 调用表达式遵循以下

![](img/bf645cf3.png)

### scheme_calc

似乎这个文件已弃用

* 函数`calc_eval` 接受一个`python`表达式，返回评估的结果
    * 对解析好的表达式进行评估，会根据其类型自动分派
* 函数`calc_apply`接受一个操作符和一系列参数，返回评估结果

![](img/213d84e8.png)

![](img/fa104f82.png)

![](img/6b5b4cb5.png)

## 解释器的用户界面

通常解释器都有一个 `读取 >> 求值 >> 循环`的过程

* 打印提示符 提示用户计算机已准备好接受输入
* 从用户读取文本
* 解析文本 进行一系列传递 得出结果
* 报告结果或错误
* 循环

![](img/e1e6c908.png)

## 异常

![](img/20c322f8.png)

## 特殊形式

在我们之前的两个函数`eval`和`apply`中只是向表达式分为数字和调用表达式

我们的`eval`函数根据传入以解析的表达式的形式对其进行调度

特殊形式一般根据第一个列表元素确定

![](img/253e04be.png)

如果不是我们已知的，其就只是一个调用表达式

这是`eval`函数的工作模式

![](img/27de62c3.png)

![](img/23209cd6.png)

### define特殊形式

define会在当前帧中创建一个新过程

其中包括**过程体**

当发生调用时，传递参数给新的帧

### 引用

是一个**特殊形式** `(quote 表达式)`

被引用的表达式不会被评估

![](img/a08877ed.png)

其有一种简写方式

![](img/abb3fb47.png)

`scheme_read`在解析时遇到`'`会转化为`(quote (1 2))`的形式

![](img/28484305.png)

### 逻辑特殊形式


