# RISC的指令表示
 
* [汇编指令集到二进制](#汇编指令集到二进制)
* [字段和类型](#字段和类型)
  * [r类型格式](#r类型格式)
  * [i类型指令格式](#i类型指令格式)
    * [加载指令](#加载指令)
  * [s类型指令格式](#s类型指令格式)

![](img/284e2c05.png)

这是我们当前位于的抽象层级！我们结束了RISC-V的学习

处理器能够理解的只有二进制树序列0 1 我们要把汇编映射到其上

计算机的发展过程

* 可插线的计算机
* 控制开关的编程计算机
* 35位作为数据的计算机
* 所有东西（数据和指令）都存在内存并具有内存地址
  * C指针也仅仅是内存地址
  * 一个重要的寄存器**PC** 存储了接下来执行指令的地址

## 汇编指令集到二进制

* 二进制程序绑定到对应指令集 不同架构的二进制程序不同
* 机器语言要向下兼任：其更新后，先前版本的程序也能运行 （新版本的手机更新了架构，我们不想重新开发其程序）

我们处理大部分数据都是32位，寄存器是32位，lw和sw都是对32位进行操作

而最基本的指令集大约40条指令，但是可扩展到几百个额外可选扩展

* 如何编号呢？我们通常不会顺序编号，比如add为1，sub2...
* 而是为其分配32位值（方便将其同样放置在内存）
  * 并且这些32位指令在所有RISCV的变体中使用 RV32 RV64 RV128

那么理论上我们可以表示2^32条指令 但是不会将其任意表示，而是**设计指令集使得其便于微处理器解释**

* **分为字段** 字段告知处理器 这条指令是什么
* 每个字段告诉处理器一些关于指令的信息：**什么类型** **对哪些寄存器操作**

## 字段和类型

* 我们有32个寄存器，因此每次使用**32位中的5位表示操作数寄存器**
* 类型 共有六种类型的操作 **每一种类型具有一种字段格式**
  * R 寄存器到寄存器的算术和逻辑运算
  * I 寄存器和立即数的算术和运算操作 以及 加载 **加载和立即数指令对于字段有相同的格式**
  * S 存储操作
  * B 分支操作
  * U 长立即数 
  * J 跳转指令

 ### r类型格式

算术逻辑运算 寄存器到寄存器的指令

![](img/e37d7eac.png)

每条指令覆盖0到31位 分为各个字段

* 最低的部分是**操作码** 占有7位 0 - 6 *opcode*
* 目标寄存器的二进制代码 占有5位 7 - 11 *rd*
* *funct3* 占有3位 12 - 14 
* 源寄存器1 占有5位 15 - 19 *rs1*
* 源寄存器2 占有5位 20 - 24 *rs2*
* *funct7* 占有7位 25 - 32 

其中操作码 funct3 funct7表示我们要执行什么指令 add 还是 sub 还是 sll

* 所有r指令的操作码相同`0b0110011`
* 剩下的funct3和funct7来区分指令（我们可以区分2^10=1024条指令，因此存在很多冗余，利用这一点选择合适的区分方法使得处理器容易确定其将执行哪条指令）
* 他们分散在各处的原因同样是让处理器工作更容易

![](img/19ab43ec.png)

所有R类型指令的摘要

![](img/f4cf55cf.png)

* `slt` `sltu`指令当源寄存器1值小于源寄存器2，设置目标寄存器为1，否则为0 `set on less than`

可以观察出一些特别之处

* `add`和`sub`仅仅用1位区分，我们用这一位是否为1决定加法器是否变为减法器（符号扩展） （相同的硬件）
* 算术右移`sra`和逻辑右移`srl`也用同样的位置区分，除了这两条指令，其他指令的这个位置都为0，因此这个位（30）表示是否**符号扩展** 
* 其他的相似之处也有巧妙的设计

### i类型指令格式

立即数和寄存器的算术逻辑运算以及加载指令

我们尽量让不同类型的指令格式大部分相同，因此其和R指令布局类似

立即数编码为指令的一部分，但是其只能占用32位中的一部分 

![](img/6cbb4015.png)

我们可以利用R指令中rs2的位置，但是5位是不够的，需要更大的立即数范围

**将R指令中与rs1字段相邻的funct7也利用起来** 12位表示立即数 功能表示2^12 = 4000多个

但是我们实际有9条I指令，而funct3只能区分8条

![](img/5e7f2421.png)

立即数范围为-2048-2047 不过我们需要其和rs1中的值匹配，因此处理器自动将其**符号扩展为32位**

![](img/838319fc.png)

* I类型的操作码为`0010011`
* 这里addi的funct3和add的相同

所有I指令的摘要

![](img/055cfb94.png)

* `slti` `sltiu` 将源寄存器数和立即数比较，小于则设置目标寄存器为1，否则为0
* 由于funct3不够区分两种指令 
  * 缩减立即数范围，用第30位区分`srli`和`srai` 和R指令中相同，也表示是否符号扩展
  * 对于移位指令，过大的立即数范围没有意义，因为最多只有32位数，当移位大于32后毫无意义，因此只要保留5位立即数即可

#### 加载指令

加载指令实际上和I指令结构相同 一个目标寄存器存放值 一个源寄存器存放内存的指针 一个立即数表示偏移量

![](img/92b6955d.png)

加载指令仅仅区分了操作码 

funct3来区分加载类型 **字** **字节** **无符号**

![](img/d17dc0a1.png)

![](img/97452fe8.png)

* `lh`用于加载**半字**
* 带`u`的版本采用0扩展 其余采用符号扩展 **w没有空间扩展，因此不需要**

### s类型指令格式

存储

store不得不采用新的格式 其使用不同的方式使用寄存器

* 两个源寄存器 一个存放数据 一个存放指向内存的指针
* 一个立即数 表示偏移量

![](img/486ce89b.png)

我们希望寄存器在指令中的位置尽可能相同，避免处理器在指令中到处寻找寄存器

因此将立即数分开 占据R指令中目标寄存器的五位和funct7的7位，共12位 -2048-2047

![](img/8f51c132.png)

![](img/e575f668.png)
